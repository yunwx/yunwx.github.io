<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>知心APP</title>
    <link href="/2025/03/05/%E7%9F%A5%E5%BF%83APP/"/>
    <url>/2025/03/05/%E7%9F%A5%E5%BF%83APP/</url>
    
    <content type="html"><![CDATA[<h2 id="一、项目简介"><a href="#一、项目简介" class="headerlink" title="一、项目简介"></a>一、项目简介</h2><ul><li>知心APP是一个整合了智能推荐、社交互动与活动管理的平台，通过加入智能推荐算法，可以更加准确地实现将用户与感兴趣的好友和社交活动匹配。</li><li>基于HarmonyOS的ArkTs前端语言结合SDK框架实现客户端开发。</li><li>基于Java编程语言完成客户端和MySQL数据库的连接，实现服务端开发。</li></ul><h2 id="二、技术简介"><a href="#二、技术简介" class="headerlink" title="二、技术简介"></a>二、技术简介</h2><ul><li>ArkUI：是HarmonyOS的声明式 UI 开发框架，用于构建HarmonyOS应用的界面。它提供了一套现代化的 UI 开发方式，支持 TypeScript&#x2F;JavaScript（ArkTS&#x2F;JS）和C++（Native UI）两种开发范式。</li><li>ArkTS：是对TypeScript进行深度优化和功能扩展的一种开发语言，完美适配ArkUI框架，保留了TypeScript基础语法的同时增加了声明式UI编程范式和组件化开发能力。</li><li>Java Socket：是Java提供的一套基于TCP&#x2F;IP协议的网络通信API，允许不同主机上的应用程序通过字节流进行双向数据传输，适用于构建客户端-服务器（C&#x2F;S）架构的应用。</li><li>MySQL：是一个开源的关系型数据库管理系统，支持高并发访问。</li></ul><h2 id="三、功能展示"><a href="#三、功能展示" class="headerlink" title="三、功能展示"></a>三、功能展示</h2><ul><li><p><strong>注册与登录</strong></p><ul><li><p>注册时，前端将注册信息发送至后端，若用户名已被注册，前端会提示用户名已存在，若注册信息无误，后端会完成注册并返回成功信息，前端提示注册成功并自动跳转至登录页面。</p></li><li><p>登录时，前端会将输入的信息发送至后端，后端连接数据库查询用户信息。若信息匹配且账号状态正常，后端返回用户数据，前端接收数据并跳转至主页；若用户名或密码错误，后端返回错误信息，前端提示用户重新输入；若用户账号已被封禁，前端提示账号已被封禁。</p></li><li><p>首次登录时，需要填写自己的昵称、出生日期、兴趣，选择兴趣是为了能够更精准地推荐好友以及活动。</p>  <img src="/2025/03/05/%E7%9F%A5%E5%BF%83APP/%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95.gif" class=""></li></ul></li><li><p><strong>添加好友</strong></p><ul><li><p>通过搜索框输入目标用户的用户名进行搜索，系统会实时显示匹配的结果，找到目标用户后点击添加即可发送好友请求。</p></li><li><p>在通讯录界面的推荐区可以查看系统根据兴趣推荐的好友，点击推荐好友后可以查看其出生日期、兴趣等基本信息，并根据自己的意愿选择是否发送好友请求。</p>  <img src="/2025/03/05/%E7%9F%A5%E5%BF%83APP/%E6%B7%BB%E5%8A%A0%E5%A5%BD%E5%8F%8B.gif" class=""></li></ul></li><li><p><strong>聊天功能</strong></p><ul><li><p>首页会显示聊天记录列表，包括最近联系的好友及其最新的聊天内容摘要。点击某个好友的聊天记录，即可进入与该好友的聊天界面，进行实时对话，聊天记录也会实时更新。</p>  <img src="/2025/03/05/%E7%9F%A5%E5%BF%83APP/%E8%81%8A%E5%A4%A9%E5%8A%9F%E8%83%BD.gif" class=""></li></ul></li><li><p><strong>活动模块</strong></p><ul><li><p>推荐活动是根据用户的兴趣标签进行个性化推荐，热门活动则展示当前点赞数前三名的活动。</p></li><li><p>每个模块下方会显示对应类别活动的简略信息，用户点击后可以进入活动详情界面，查看更详细的信息。</p></li><li><p>活动详情界面可以点赞、评论和参加该活动。</p></li><li><p>创建活动时填写完活动信息并提交后会进入审核状态。</p></li><li><p>已报名和已创建的活动可以在“我的活动”页面中集中查看和管理。</p>  <img src="/2025/03/05/%E7%9F%A5%E5%BF%83APP/%E6%B4%BB%E5%8A%A8%E5%8A%9F%E8%83%BD.gif" class=""></li></ul></li><li><p><strong>个性化推荐</strong></p><ul><li><p>通过用户的标签推荐好友与活动。</p>  <img src="/2025/03/05/%E7%9F%A5%E5%BF%83APP/%E6%8E%A8%E8%8D%90%E5%8A%9F%E8%83%BD.gif" class=""></li></ul></li><li><p><strong>标签更新</strong></p><ul><li><p>采用动态标签机制。</p></li><li><p>用户标签由两部分构成：显式标签（用户自主选择）与隐式标签（系统根据用户行为自动生成）。</p>  <img src="/2025/03/05/%E7%9F%A5%E5%BF%83APP/%E6%A0%87%E7%AD%BE%E6%9B%B4%E6%96%B0.gif" class=""></li></ul></li><li><p><strong>退出登录</strong></p><ul><li><p>退出登录后前端清除本地缓存的用户信息，并自动跳转至登录页面。</p>  <img src="/2025/03/05/%E7%9F%A5%E5%BF%83APP/%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95.gif" class=""></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>HarmonyOS</tag>
      
      <tag>ArkTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全栈技术问题</title>
    <link href="/2025/02/23/%E5%85%A8%E6%A0%88%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2025/02/23/%E5%85%A8%E6%A0%88%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-详细解释JVM内存模型（堆、栈、方法区等），并说明垃圾回收机制在高并发场景下的优化思路。"><a href="#1-详细解释JVM内存模型（堆、栈、方法区等），并说明垃圾回收机制在高并发场景下的优化思路。" class="headerlink" title="1.详细解释JVM内存模型（堆、栈、方法区等），并说明垃圾回收机制在高并发场景下的优化思路。"></a>1.详细解释JVM内存模型（堆、栈、方法区等），并说明垃圾回收机制在高并发场景下的优化思路。</h3><ul><li>JVM内存模型：<ul><li>堆（Heap）：存放对象实例，是所有线程共享的，分为新生代（Eden、Survivor区）和老年代。</li><li>栈（Stack）：线程私有，存放局部变量、方法调用栈帧。</li><li>方法区（Metaspace&#x2F;JDK8+）：存储类信息、常量池、静态变量等。</li><li>程序计数器（PC Register）：记录当前线程执行到的字节码行号。</li><li>本地方法栈（Native Method Stack）：执行Native方法（如JNI调用）。</li></ul></li><li>高并发下的GC优化：<ul><li>选择合适的垃圾回收器：如G1或ZGC，减少STW（Stop-The-World）时间。</li><li>调整堆大小：避免频繁Full GC，如-Xms和-Xmx设为相同值，减少动态扩展的开销。</li><li>优化对象分配：减少大对象直接进入老年代，合理设置-XX:MaxTenuringThreshold。</li><li>避免内存泄漏：如使用WeakHashMap管理缓存，防止长生命周期对象持有短生命周期对象的引用。</li></ul></li></ul><h3 id="2-举例说明什么情况下会触发OutOfMemoryError，如何通过工具（如MAT）分析内存泄漏？"><a href="#2-举例说明什么情况下会触发OutOfMemoryError，如何通过工具（如MAT）分析内存泄漏？" class="headerlink" title="2.举例说明什么情况下会触发OutOfMemoryError，如何通过工具（如MAT）分析内存泄漏？"></a>2.举例说明什么情况下会触发OutOfMemoryError，如何通过工具（如MAT）分析内存泄漏？</h3><ul><li>OOM触发场景：<ul><li>堆内存不足：java.lang.OutOfMemoryError: Java heap space（对象过多或内存泄漏）。</li><li>方法区溢出：java.lang.OutOfMemoryError: Metaspace（动态加载大量类）。</li><li>栈溢出：java.lang.StackOverflowError（递归调用过深）。</li></ul></li><li>MAT（Memory Analyzer Tool）分析步骤：<br>  a.使用jmap -dump:format&#x3D;b,file&#x3D;heap.hprof &lt; pid &gt;导出堆内存快照。<br>  b.用MAT打开.hprof文件，分析Dominator Tree，查看占用内存最多的对象。<br>  c.检查Leak Suspects报告，定位可能的泄漏点（如未关闭的连接、静态集合类）。</li></ul><h3 id="3-使用过vue哪些功能？"><a href="#3-使用过vue哪些功能？" class="headerlink" title="3.使用过vue哪些功能？"></a>3.使用过vue哪些功能？</h3><p>(1)组件化开发：通过 Vue 的组件系统，将审核模块（如印章审核、工单审核）拆分为可复用的组件，提升代码维护性。<br>(2)数据绑定与响应式系统：利用 v-model 实现表单输入的双向绑定，并结合 Vue 的响应式特性实时更新界面状态。<br>(3)指令应用：</p><ul><li>v-for：渲染待审核的工单或印章列表</li><li>v-if &#x2F; v-show：根据权限或审核状态动态显示界面元素</li></ul><p>(4)ElementUI 组件库：集成 ElementUI 的表格（el-table）、表单（el-form）、弹窗（el-dialog）等组件，快速构建用户界面。<br>(5)前端路由：通过 Vue Router 实现页面跳转（如从列表页跳转至详情页）。<br>(6)API 通信：使用 axios 或 fetch 调用后端 Spring Boot 接口，完成审核数据的提交与查询。<br>(7)事件处理：通过 @click 等事件监听用户操作（如审核通过、拒绝按钮点击）。<br>(8)状态管理：可能结合 Vuex 管理全局状态（如用户权限、审核流程状态）。</p><h3 id="4-MyBatis-和-MyBatis-Plus-的主要区别"><a href="#4-MyBatis-和-MyBatis-Plus-的主要区别" class="headerlink" title="4.MyBatis 和 MyBatis-Plus 的主要区别?"></a>4.MyBatis 和 MyBatis-Plus 的主要区别?</h3><p>(1)定位与功能</p><ul><li>MyBatis<ul><li>核心功能：一个轻量级的 Java 持久层框架，专注于 SQL 与 Java 对象的映射（ORM），开发者需手动编写 SQL 和 DAO 层代码。</li><li>特点：灵活性强，适合需要精细化控制 SQL 的场景，但对基础 CRUD 操作需要重复编码。</li></ul></li><li>MyBatis-Plus<ul><li>核心功能：基于 MyBatis 的增强工具，在保留 MyBatis 所有特性的基础上，提供了大量开箱即用的功能，大幅简化开发。</li><li>特点：内置通用 Mapper、代码生成器、分页插件、条件构造器等，显著减少重复代码。</li></ul></li></ul><p>(2)核心特性对比</p><img src="/2025/02/23/%E5%85%A8%E6%A0%88%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/MyBatis.jpg" class=""><p>(3)开发效率</p><ul><li>MyBatis：适合对 SQL 有高度定制化需求的场景，但需要开发者自行处理大量模板代码（如 CRUD 操作）。</li><li>MyBatis-Plus：通过自动化工具和增强功能，减少 80% 的基础代码量，尤其适合快速开发标准化业务。</li></ul><p>(4)实际应用场景</p><ul><li>选择 MyBatis：<ul><li>需要完全控制 SQL 逻辑（如复杂查询、存储过程调用）。</li><li>项目对第三方依赖敏感，希望保持轻量化。</li></ul></li><li>选择 MyBatis-Plus：<ul><li>需要快速实现基础 CRUD 功能（如后台管理系统）。</li><li>希望减少重复代码，提升开发效率。</li></ul></li></ul><h3 id="5-能否举例说明synchronized和ReentrantLock的区别？"><a href="#5-能否举例说明synchronized和ReentrantLock的区别？" class="headerlink" title="5.能否举例说明synchronized和ReentrantLock的区别？"></a>5.能否举例说明synchronized和ReentrantLock的区别？</h3><ul><li>实现机制：synchronized是JVM层面的关键字，依赖内置锁（Monitor），而ReentrantLock是API层面的锁，基于AQS（AbstractQueuedSynchronizer）。</li><li>功能扩展：ReentrantLock支持公平锁、可中断锁、超时锁等特性，synchronized仅支持非公平锁。</li><li>示例场景：在需要尝试获取锁或避免死锁时，使用ReentrantLock更灵活。例如，在分布式任务调度中，结合tryLock()实现超时等待。</li></ul><h3 id="6-如何判断一个SQL是否需要添加索引？"><a href="#6-如何判断一个SQL是否需要添加索引？" class="headerlink" title="6.如何判断一个SQL是否需要添加索引？"></a>6.如何判断一个SQL是否需要添加索引？</h3><ul><li>慢查询分析：通过EXPLAIN分析执行计划，观察type字段是否为ALL（全表扫描），或rows值是否过大。</li><li>高频查询字段：对WHERE、JOIN、ORDER BY子句中的高频字段添加索引。</li><li>覆盖索引：若查询仅需索引字段，可避免回表。</li></ul><h3 id="7-如何解决缓存穿透问题？"><a href="#7-如何解决缓存穿透问题？" class="headerlink" title="7.如何解决缓存穿透问题？"></a>7.如何解决缓存穿透问题？</h3><ul><li>空值缓存：对查询结果为空的Key也进行缓存（设置较短过期时间），避免频繁查询数据库。</li><li>布隆过滤器：在查询前通过布隆过滤器判断Key是否存在，拦截无效请求。</li></ul><h3 id="8-什么是缓存穿透、击穿、雪崩以及解决方案。"><a href="#8-什么是缓存穿透、击穿、雪崩以及解决方案。" class="headerlink" title="8.什么是缓存穿透、击穿、雪崩以及解决方案。"></a>8.什么是缓存穿透、击穿、雪崩以及解决方案。</h3><p>(1) 缓存穿透（Cache Penetration）</p><ul><li>定义：查询一个数据库中不存在的数据，导致请求直接打到数据库，缓存失去作用。</li><li>原因：恶意请求或非法查询。</li><li>解决方案：<ul><li>布隆过滤器（Bloom Filter）：在缓存层前加布隆过滤器，过滤掉不存在的数据。</li><li>缓存空值：即使查询结果为空，也将空结果缓存，设置较短的过期时间。</li></ul></li></ul><p>(2) 缓存击穿（Cache Breakdown）</p><ul><li>定义：某个热点数据在缓存中过期，同时有大量请求访问该数据，导致请求直接打到数据库。</li><li>原因：热点数据集中过期。</li><li>解决方案：<ul><li>设置热点数据永不过期：对热点数据不设置过期时间，或通过异步任务定期更新。</li><li>互斥锁（Mutex Lock）：当缓存失效时，只允许一个线程去查询数据库并更新缓存，其他线程等待。</li></ul></li></ul><p>(3) 缓存雪崩（Cache Avalanche）</p><ul><li>定义：大量缓存数据在同一时间过期，导致大量请求直接打到数据库，造成数据库压力激增。</li><li>原因：缓存集中过期或缓存服务宕机。</li><li>解决方案：<ul><li>分散过期时间：为缓存数据设置随机的过期时间，避免集中过期。</li><li>多级缓存：使用多级缓存（如本地缓存 + Redis），减少对单一缓存的依赖。</li><li>高可用架构：通过 Redis 集群或哨兵模式保证缓存服务的高可用性。</li></ul></li></ul><h3 id="9-Redis-数据类型"><a href="#9-Redis-数据类型" class="headerlink" title="9.Redis 数据类型"></a>9.Redis 数据类型</h3><p>(1) String（字符串）：</p><ul><li>最基本的数据类型，可以存储文本、数字或二进制数据。</li><li>常用命令：SET, GET, INCR, DECR。</li></ul><p>(2) Hash（哈希）：</p><ul><li>类似于字典，存储键值对集合，适合存储对象。</li><li>常用命令：HSET, HGET, HGETALL, HDEL。</li></ul><p>(3) List（列表）：</p><ul><li>有序的字符串列表，支持从两端插入或删除元素。</li><li>常用命令：LPUSH, RPUSH, LPOP, RPOP, LRANGE。</li></ul><p>(4) Set（集合）：</p><ul><li>无序且唯一的字符串集合，支持交集、并集等操作。</li><li>常用命令：SADD, SMEMBERS, SINTER, SUNION。</li></ul><p>(5) Sorted Set（有序集合）：</p><ul><li>类似于 Set，但每个元素关联一个分数，用于排序。</li><li>常用命令：ZADD, ZRANGE, ZSCORE, ZREM。</li></ul><p>(6) Bitmaps（位图）：</p><ul><li>通过位操作存储布尔值，适合存储标志位或进行位运算。</li><li>常用命令：SETBIT, GETBIT, BITCOUNT。</li></ul><p>(7) HyperLogLog：</p><ul><li>用于基数统计，适合估算集合中唯一元素的数量。</li><li>常用命令：PFADD, PFCOUNT, PFMERGE。</li></ul><p>(8) Geospatial（地理空间）：</p><ul><li>存储地理位置信息，支持计算距离、范围查询等操作。</li><li>常用命令：GEOADD, GEODIST, GEORADIUS。</li></ul><h3 id="10-熟悉哪些设计模式？请举例说明在项目中如何使用设计模式。"><a href="#10-熟悉哪些设计模式？请举例说明在项目中如何使用设计模式。" class="headerlink" title="10. 熟悉哪些设计模式？请举例说明在项目中如何使用设计模式。"></a>10. 熟悉哪些设计模式？请举例说明在项目中如何使用设计模式。</h3><ul><li>我熟悉常用的设计模式，如单例模式、工厂模式、观察者模式等。</li><li>在一个项目中，我使用了单例模式来确保数据库连接池的唯一性，避免重复创建连接。此外，我还使用了工厂模式来创建不同类型的支付对象（如支付宝、微信支付），通过工厂类来统一管理支付对象的创建。</li></ul><h3 id="11-你如何使用Git进行版本控制？请描述你在团队协作中的Git工作流程。"><a href="#11-你如何使用Git进行版本控制？请描述你在团队协作中的Git工作流程。" class="headerlink" title="11. 你如何使用Git进行版本控制？请描述你在团队协作中的Git工作流程。"></a>11. 你如何使用Git进行版本控制？请描述你在团队协作中的Git工作流程。</h3><ul><li>我通常使用Git进行代码版本管理，常用的命令包括git clone、git pull、git commit、git push等。</li><li>在团队协作中，我们采用Git Flow工作流。每个新功能或修复都会从develop分支创建一个新的特性分支，开发完成后通过Pull Request合并回develop分支。发布时，我们会从develop分支创建release分支，经过测试后再合并到master分支。</li></ul><h3 id="12-你如何优化MySQL查询性能？请举例说明你在项目中如何进行数据库优化。"><a href="#12-你如何优化MySQL查询性能？请举例说明你在项目中如何进行数据库优化。" class="headerlink" title="12. 你如何优化MySQL查询性能？请举例说明你在项目中如何进行数据库优化。"></a>12. 你如何优化MySQL查询性能？请举例说明你在项目中如何进行数据库优化。</h3><ul><li>我通常通过以下几种方式优化MySQL查询性能：<br>i.使用索引：为常用的查询字段创建索引，避免全表扫描。<br>ii.优化SQL语句：避免使用SELECT *，只查询需要的字段；避免使用子查询和不必要的JOIN。<br>iii.分库分表：对于大数据量的表，采用分库分表策略。</li><li>在一个电商项目中，我通过为订单表的user_id和order_date字段创建复合索引，显著提升了查询性能。</li></ul><h3 id="13-你如何使用Redis？请举例说明你在项目中如何使用Redis解决实际问题。"><a href="#13-你如何使用Redis？请举例说明你在项目中如何使用Redis解决实际问题。" class="headerlink" title="13. 你如何使用Redis？请举例说明你在项目中如何使用Redis解决实际问题。"></a>13. 你如何使用Redis？请举例说明你在项目中如何使用Redis解决实际问题。</h3><ul><li>Redis是一个高性能的键值存储系统，常用于缓存、会话管理和消息队列等场景。</li><li>在一个高并发的电商项目中，我使用Redis缓存商品详情信息，减少数据库的查询压力。当用户请求商品详情时，首先从Redis中获取数据，如果缓存中没有，再从数据库中查询并写入Redis。</li></ul><h3 id="14-你熟悉Spring-Cloud吗？请举例说明你在微服务架构中如何使用Spring-Cloud。"><a href="#14-你熟悉Spring-Cloud吗？请举例说明你在微服务架构中如何使用Spring-Cloud。" class="headerlink" title="14. 你熟悉Spring Cloud吗？请举例说明你在微服务架构中如何使用Spring Cloud。"></a>14. 你熟悉Spring Cloud吗？请举例说明你在微服务架构中如何使用Spring Cloud。</h3><ul><li>我熟悉Spring Cloud，它是一套用于构建微服务架构的工具集，包括服务发现（Eureka）、配置管理（Config）、负载均衡（Ribbon）等。</li><li>在一个微服务项目中，我使用Eureka作为服务注册中心，各个微服务在启动时向Eureka注册，服务之间通过Ribbon进行负载均衡调用。此外，我还使用Spring Cloud Config来集中管理各个微服务的配置。</li></ul><h3 id="15-你如何理解前端框架Vue？请举例说明你在项目中如何使用Vue。"><a href="#15-你如何理解前端框架Vue？请举例说明你在项目中如何使用Vue。" class="headerlink" title="15. 你如何理解前端框架Vue？请举例说明你在项目中如何使用Vue。"></a>15. 你如何理解前端框架Vue？请举例说明你在项目中如何使用Vue。</h3><ul><li>Vue是一个渐进式JavaScript框架，用于构建用户界面。它采用组件化开发模式，数据驱动视图更新。</li><li>在一个后台管理系统中，我使用Vue构建了前端页面。通过Vue的组件化开发，我将页面拆分为多个可复用的组件，如导航栏、表格、表单等。同时，我使用Vuex进行状态管理，确保各个组件之间的数据共享和同步。</li></ul><h3 id="16-面向对象编程（OOP）的三大特性是："><a href="#16-面向对象编程（OOP）的三大特性是：" class="headerlink" title="16.面向对象编程（OOP）的三大特性是："></a>16.面向对象编程（OOP）的三大特性是：</h3><p>(1) 封装（Encapsulation）：</p><ul><li>将数据和操作数据的方法绑定，隐藏内部实现，仅通过接口与外界交互。</li><li>优点：提高代码安全性，便于维护和复用。</li></ul><p>(2) 继承（Inheritance）：</p><ul><li>子类继承父类的属性和方法，并可扩展或重写。</li><li>优点：减少代码重复，增强可扩展性。</li></ul><p>(3) 多态（Polymorphism）：</p><ul><li>同一操作在不同对象上有不同表现，通常通过方法重写和接口实现。</li><li>优点：提高代码灵活性和可扩展性。</li></ul><h3 id="17-单例模式实现方式："><a href="#17-单例模式实现方式：" class="headerlink" title="17.单例模式实现方式："></a>17.单例模式实现方式：</h3><p>(1) 懒汉式（Lazy Initialization）：在第一次调用时创建实例。</p><ul><li>优点：延迟加载，节省资源。</li><li>缺点：非线程安全，多线程环境下可能创建多个实例。</li></ul><p>(2) 饿汉式（Eager Initialization）：在类加载时创建实例。</p><ul><li>优点：线程安全，实现简单。</li><li>缺点：类加载时就创建实例，可能浪费资源。</li></ul><p>(3) 静态内部类（Static Inner Class）：利用类加载机制保证线程安全，同时实现延迟加载。</p><ul><li>优点：线程安全，延迟加载，实现简单。</li><li>缺点：无法传递参数初始化实例。</li></ul><h3 id="18-MySQL索引"><a href="#18-MySQL索引" class="headerlink" title="18.MySQL索引"></a>18.MySQL索引</h3><p>（1）按数据结构分类</p><ul><li>B+Tree 索引：<ul><li>MySQL 默认的索引类型，适用于全键值、键值范围和键值前缀查询。</li><li>支持 &#x3D;、&gt;、&lt;、BETWEEN、IN 等操作。</li></ul></li><li>Hash 索引：<ul><li>基于哈希表实现，适用于等值查询（&#x3D;），不支持范围查询。</li><li>内存存储引擎（如 MEMORY）支持 Hash 索引。</li></ul></li><li>全文索引（FULLTEXT）：<ul><li>用于全文搜索，适用于 MATCH AGAINST 操作。</li><li>仅支持 InnoDB 和 MyISAM 存储引擎。</li></ul></li><li>空间索引（R-Tree）：<ul><li>用于地理空间数据，支持几何数据类型。<br>（2）按功能分类</li></ul></li><li>普通索引（INDEX）：<ul><li>最基本的索引，没有任何约束。</li></ul></li><li>唯一索引（UNIQUE INDEX）：<ul><li>确保索引列的值唯一，允许有空值。</li></ul></li><li>主键索引（PRIMARY KEY）：<ul><li>特殊的唯一索引，不允许有空值，每个表只能有一个主键。</li></ul></li><li>组合索引（复合索引）：<ul><li>对多个列联合创建的索引，遵循最左前缀原则。</li></ul></li><li>前缀索引：<ul><li>对列的前缀部分创建索引，节省存储空间。</li></ul></li></ul><h3 id="19-MySQL表常见连接方式"><a href="#19-MySQL表常见连接方式" class="headerlink" title="19.MySQL表常见连接方式"></a>19.MySQL表常见连接方式</h3><p>(1) LEFT JOIN（左连接）</p><ul><li>定义：以左表（LEFT JOIN 左侧的表）为基准，返回左表的所有行，即使右表中没有匹配的行。</li><li>结果：<ul><li>如果右表有匹配的行，则返回匹配的数据。</li><li>如果右表没有匹配的行，则右表的列返回NULL。</li></ul></li></ul><p>(2) RIGHT JOIN（右连接）</p><ul><li>定义：以右表（RIGHT JOIN 右侧的表）为基准，返回右表的所有行，即使左表中没有匹配的行。</li><li>结果：<ul><li>如果左表有匹配的行，则返回匹配的数据。</li><li>如果左表没有匹配的行，则左表的列返回 NULL。</li></ul></li></ul><p>(3) INNER JOIN（内连接）</p><ul><li>定义：返回两个表中匹配的行。如果某一行在其中一个表中没有匹配，则不会返回该行。</li></ul><p>(4) FULL OUTER JOIN（全外连接）</p><ul><li>定义：返回两个表中所有行，无论是否匹配。如果某一行在其中一个表中没有匹配，则缺失的部分用 NULL 填充。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>MySQL</tag>
      
      <tag>Vue</tag>
      
      <tag>MyBatis</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring生态</title>
    <link href="/2025/02/17/Spring%E7%94%9F%E6%80%81/"/>
    <url>/2025/02/17/Spring%E7%94%9F%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Spring-Boot"><a href="#一、Spring-Boot" class="headerlink" title="一、Spring Boot"></a>一、Spring Boot</h2><h3 id="1-核心注解"><a href="#1-核心注解" class="headerlink" title="1. 核心注解"></a>1. 核心注解</h3><ul><li>@Component: 标记一个类为 Spring 容器管理的组件，通用的注解。</li><li>@Service: 标记一个类为服务层组件，通常用于业务逻辑层。</li><li>@Repository: 标记一个类为数据访问层组件，通常用于 DAO 层。</li><li>@Controller: 标记一个类为控制器组件，通常用于 MVC 模式中的控制器。</li><li>@RestController: 结合了 @Controller 和 @ResponseBody，用于 RESTful Web 服务。</li></ul><h3 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2. 依赖注入"></a>2. 依赖注入</h3><ul><li>@Autowired: 自动注入依赖，可以用于字段、构造器或方法。</li><li>@Qualifier: 与 @Autowired 一起使用，指定要注入的 bean 的名称。</li><li>@Resource: 类似于 @Autowired，但按名称注入。</li><li>@Value: 注入属性值，通常用于从配置文件中读取值。</li></ul><h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h3><ul><li>@Configuration: 标记一个类为配置类，通常与 @Bean 一起使用。</li><li>@Bean: 标记一个方法返回的对象为 Spring 容器管理的 bean。</li><li>@ComponentScan: 指定 Spring 扫描组件的包路径。</li><li>@PropertySource: 指定属性文件的位置，用于加载配置。</li></ul><h3 id="4-AOP（面向切面编程）"><a href="#4-AOP（面向切面编程）" class="headerlink" title="4. AOP（面向切面编程）"></a>4. AOP（面向切面编程）</h3><ul><li>@Aspect: 标记一个类为切面类。</li><li>@Before: 在目标方法执行前执行。</li><li>@After: 在目标方法执行后执行，无论是否抛出异常。</li><li>@AfterReturning: 在目标方法成功返回后执行。</li><li>@AfterThrowing: 在目标方法抛出异常后执行。</li><li>@Around: 环绕通知，可以在目标方法执行前后执行自定义逻辑。</li></ul><h3 id="5-事务管理"><a href="#5-事务管理" class="headerlink" title="5. 事务管理"></a>5. 事务管理</h3><ul><li>@Transactional: 标记一个方法或类为事务性的，用于声明式事务管理。</li></ul><h2 id="二、Mybatis"><a href="#二、Mybatis" class="headerlink" title="二、Mybatis"></a>二、Mybatis</h2><h3 id="1-什么是MyBatis？"><a href="#1-什么是MyBatis？" class="headerlink" title="1. 什么是MyBatis？"></a>1. 什么是MyBatis？</h3><p>MyBatis是一个基于Java的持久层框架，它封装了JDBC操作，简化了数据库访问。MyBatis通过XML或注解将Java对象与SQL语句进行映射，开发者可以直接编写SQL语句，灵活地控制查询逻辑。</p><h3 id="2-MyBatis的核心组件有哪些？"><a href="#2-MyBatis的核心组件有哪些？" class="headerlink" title="2. MyBatis的核心组件有哪些？"></a>2. MyBatis的核心组件有哪些？</h3><ul><li>SqlSessionFactory：用于创建SqlSession的工厂类，是MyBatis的核心对象。</li><li>SqlSession：表示一次数据库会话，用于执行SQL语句、获取Mapper接口。</li><li>Mapper接口：定义了数据库操作的方法，MyBatis通过动态代理实现接口。</li><li>Mapper XML文件：定义了SQL语句和结果映射规则。</li><li>Configuration：包含了MyBatis的全局配置信息。</li></ul><h3 id="3-MyBatis中-和-的区别是什么？"><a href="#3-MyBatis中-和-的区别是什么？" class="headerlink" title="3. MyBatis中#{}和${}的区别是什么？"></a>3. MyBatis中#{}和${}的区别是什么？</h3><ul><li>#{}：<ul><li>是预编译占位符，MyBatis会将#{}替换为?，并通过PreparedStatement设置参数，防止SQL注入。</li><li>适用于传递参数值。</li></ul></li><li>${}：<ul><li>是字符串替换，MyBatis会直接将${}替换为变量的值，存在SQL注入风险。</li><li>适用于动态表名、列名等场景。</li></ul></li></ul><h3 id="4-MyBatis如何实现分页？"><a href="#4-MyBatis如何实现分页？" class="headerlink" title="4. MyBatis如何实现分页？"></a>4. MyBatis如何实现分页？</h3><ul><li>逻辑分页：使用MyBatis的RowBounds对象，在内存中进行分页，适合数据量小的场景。</li><li>物理分页：在SQL语句中使用LIMIT和OFFSET（MySQL）或ROWNUM（Oracle）实现分页。</li><li>分页插件：使用PageHelper等分页插件，简化分页操作。</li></ul><h3 id="5-MyBatis的一级缓存和二级缓存有什么区别？"><a href="#5-MyBatis的一级缓存和二级缓存有什么区别？" class="headerlink" title="5. MyBatis的一级缓存和二级缓存有什么区别？"></a>5. MyBatis的一级缓存和二级缓存有什么区别？</h3><ul><li>一级缓存：<ul><li>默认开启，作用域为SqlSession级别。</li><li>在同一个SqlSession中，相同的查询会直接从缓存中获取结果。</li><li>当SqlSession关闭或执行增删改操作时，缓存会被清空。</li></ul></li><li>二级缓存：<ul><li>需要手动开启，作用域为Mapper级别（跨SqlSession）。</li><li>多个SqlSession可以共享二级缓存。</li><li>适合读取频繁、更新较少的场景。</li></ul></li></ul><h3 id="6-MyBatis如何实现多表关联查询？"><a href="#6-MyBatis如何实现多表关联查询？" class="headerlink" title="6. MyBatis如何实现多表关联查询？"></a>6. MyBatis如何实现多表关联查询？</h3><ul><li>嵌套查询：在主查询中通过&lt; association &gt;或&lt; collection &gt;标签嵌套子查询。</li><li>嵌套结果：通过JOIN查询一次性获取所有数据，然后在结果映射中使用&lt; association &gt;或&lt; collection &gt;标签映射关联对象。</li></ul><h3 id="7-MyBatis的动态SQL有哪些标签？"><a href="#7-MyBatis的动态SQL有哪些标签？" class="headerlink" title="7. MyBatis的动态SQL有哪些标签？"></a>7. MyBatis的动态SQL有哪些标签？</h3><ul><li>&lt; if &gt;： 条件判断。</li><li>&lt; choose &gt;、&lt; when &gt;、&lt; otherwise &gt;： 多条件选择。</li><li>&lt; where &gt;： 动态生成WHERE子句。</li><li>&lt; set &gt;： 动态生成SET子句。</li><li>&lt; foreach &gt;： 遍历集合，生成IN语句或批量操作。</li><li>&lt; trim &gt;： 去除多余的字符（如AND、OR）。</li></ul><h3 id="8-MyBatis如何实现批量插入？"><a href="#8-MyBatis如何实现批量插入？" class="headerlink" title="8. MyBatis如何实现批量插入？"></a>8. MyBatis如何实现批量插入？</h3><ul><li>使用&lt; foreach &gt;标签遍历集合，生成多条INSERT语句。</li><li>使用SqlSession的batch方法实现批量操作。</li></ul><h3 id="9-MyBatis如何解决SQL注入问题？"><a href="#9-MyBatis如何解决SQL注入问题？" class="headerlink" title="9. MyBatis如何解决SQL注入问题？"></a>9. MyBatis如何解决SQL注入问题？</h3><ul><li>使用#{}预编译占位符，避免直接拼接SQL。</li><li>避免使用${}进行字符串替换，除非是动态表名、列名等场景。</li><li>对用户输入进行严格的校验和过滤。</li></ul><h2 id="三、Spring-Cloud"><a href="#三、Spring-Cloud" class="headerlink" title="三、Spring Cloud"></a>三、Spring Cloud</h2><h3 id="1-服务注册与发现"><a href="#1-服务注册与发现" class="headerlink" title="1. 服务注册与发现"></a>1. 服务注册与发现</h3><ul><li>@EnableEurekaClient: 启用 Eureka 客户端，将服务注册到 Eureka 服务器。</li><li>@EnableDiscoveryClient: 启用服务发现客户端，适用于多种服务发现工具（如 Eureka、Consul、Zookeeper）。</li><li>@LoadBalanced: 标记 RestTemplate 或 WebClient，使其具备负载均衡能力。</li></ul><h3 id="2-配置管理"><a href="#2-配置管理" class="headerlink" title="2. 配置管理"></a>2. 配置管理</h3><ul><li>@EnableConfigServer: 启用配置服务器，集中管理微服务的配置。</li><li>@RefreshScope: 标记 Bean，使其在配置更改时能够动态刷新。</li></ul><h3 id="3-API-网关"><a href="#3-API-网关" class="headerlink" title="3. API 网关"></a>3. API 网关</h3><ul><li>@EnableZuulProxy: 启用 Zuul 代理，用于 API 网关路由和过滤。</li><li>@EnableZuulServer: 启用 Zuul 服务器，提供基本的网关功能。</li><li>@EnableGateway: 启用 Spring Cloud Gateway，提供更强大的 API 网关功能。</li></ul><h3 id="4-熔断器与限流"><a href="#4-熔断器与限流" class="headerlink" title="4. 熔断器与限流"></a>4. 熔断器与限流</h3><ul><li>@EnableHystrix: 启用 Hystrix 熔断器，提供容错和延迟容忍能力。</li><li>@HystrixCommand: 标记方法，使其具备熔断器功能。</li><li>@EnableCircuitBreaker: 启用熔断器功能，适用于多种熔断器实现（如 Hystrix、Resilience4j）。</li><li>@SentinelResource: 标记方法，使其具备 Sentinel 的限流和熔断功能。</li></ul><h3 id="5-分布式追踪"><a href="#5-分布式追踪" class="headerlink" title="5. 分布式追踪"></a>5. 分布式追踪</h3><ul><li>@EnableSleuth: 启用 Sleuth，提供分布式追踪功能。</li><li>@NewSpan: 标记方法，使其在追踪中创建一个新的 Span。</li></ul><h3 id="6-消息驱动"><a href="#6-消息驱动" class="headerlink" title="6. 消息驱动"></a>6. 消息驱动</h3><ul><li>@EnableBinding: 启用消息绑定，将应用程序与消息中间件（如 Kafka、RabbitMQ）连接。</li><li>@StreamListener: 标记方法，使其监听消息通道中的消息。</li></ul><h2 id="四、Spring-Security"><a href="#四、Spring-Security" class="headerlink" title="四、Spring Security"></a>四、Spring Security</h2><h3 id="1-EnableWebSecurity"><a href="#1-EnableWebSecurity" class="headerlink" title="1.@EnableWebSecurity"></a>1.@EnableWebSecurity</h3><ul><li>启用 Spring Security 的 Web 安全支持。</li><li>通常用于配置类上，表示该类是 Spring Security 的配置类。</li></ul><h3 id="2-PreAuthorize"><a href="#2-PreAuthorize" class="headerlink" title="2.@PreAuthorize"></a>2.@PreAuthorize</h3><ul><li>在方法执行前进行权限检查。</li><li>支持 SpEL（Spring Expression Language）表达式。</li></ul><h3 id="3-Secured"><a href="#3-Secured" class="headerlink" title="3.@Secured"></a>3.@Secured</h3><ul><li>用于指定方法所需的角色。</li><li>不支持 SpEL，仅支持简单的角色名称。</li></ul><h3 id="4-WithAnonymousUser"><a href="#4-WithAnonymousUser" class="headerlink" title="4.@WithAnonymousUser"></a>4.@WithAnonymousUser</h3><ul><li>用于测试，模拟匿名用户。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Spring Boot</tag>
      
      <tag>Mybatis</tag>
      
      <tag>Spring Cloud</tag>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习笔记</title>
    <link href="/2025/02/12/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/02/12/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1-简介："><a href="#1-简介：" class="headerlink" title="1.简介："></a>1.简介：</h3><ul><li>Vue是渐进式JavaScript框架，基于标准HTML、CSS和JavaScript构建，并提供了一套声明式、组件化的编程模型。</li></ul><h3 id="2-准备："><a href="#2-准备：" class="headerlink" title="2.准备："></a>2.准备：</h3><ul><li>引入Vue模块（官方提供）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script type=&quot;module&quot;&gt;<br>    import &#123; createApp &#125; from &#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>创建Vue程序的应用实例，控制视图元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script type=&quot;module&quot;&gt;<br>    import &#123; createApp &#125; from &#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;;<br>    createApp(&#123;<br>    <br>    &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>准备元素（div），被Vue控制（调用mount方法）</li></ul><div id="app"></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script type=&quot;module&quot;&gt;<br>    import &#123; createApp &#125; from &#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;;<br>    createApp(&#123;<br>    <br>    &#125;).mount(&quot;#app&quot;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="3-数据驱动视图："><a href="#3-数据驱动视图：" class="headerlink" title="3.数据驱动视图："></a>3.数据驱动视图：</h3><ul><li>准备数据</li></ul><div id="app"></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script type=&quot;module&quot;&gt;<br>    import &#123; createApp &#125; from &#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;;<br>    createApp(&#123;<br>        data()&#123;<br>            return&#123;<br>                message: &quot;Hello Vue&quot;            <br>            &#125;        <br>        &#125;<br>    &#125;).mount(&quot;#app&quot;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>通过插值表达式渲染页面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div id=&quot;app&quot;&gt;<br>    &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;<br>&lt;/div&gt;<br>&lt;script type=&quot;module&quot;&gt;<br>    import &#123; createApp &#125; from &#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;;<br>    createApp(&#123;<br>        data()&#123;<br>            return&#123;<br>                message: &quot;Hello Vue&quot;            <br>            &#125;        <br>        &#125;<br>    &#125;).mount(&quot;#app&quot;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><span style="color:#FF6B6B">注：插值表达式不能出现在标签内部</span></p><h3 id="4-常用指令："><a href="#4-常用指令：" class="headerlink" title="4.常用指令："></a>4.常用指令：</h3><ul><li><p>v-for：列表渲染，遍历容器的元素或者对象的属性</p><ul><li>语法：<span style="color:#FF6B6B">v-for&#x3D;”(item,index) in items” :key&#x3D;”item.id”</span></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;tr v-for=&quot;(item,index) in items&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/tr&gt;<br></code></pre></td></tr></table></figure><ul><li>参数说明：<ul><li>items为遍历的数组</li><li>item为遍历出来的元素</li><li>index为索引&#x2F;下标，从0开始；可以省略，省略index语法：v-for&#x3D;”item in items”</li></ul></li><li>key：<ul><li>作用：给元素添加的唯一标识，便于vue进行列表项的正确排序复用，提升渲染性能</li><li>推荐使用id作为key（唯一），不推荐使用index作为key（会变化，不对应）</li></ul></li></ul></li></ul><p><span style="color:#FF6B6B">注：遍历的数组必须在data中定义；要想让哪个标签循环展示多次，就在哪个标签上使用 v-for 指令</span></p><ul><li>v-bind：动态为HTML标签绑定属性值，如设置 href，css样式等<ul><li>语法：<span style="color:#FF6B6B">v-bind:属性名&#x3D;”属性值”</span>，可简化为：<span style="color:#FF6B6B">:属性名&#x3D;”属性值”</span></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;img v-bind:src=&quot;item.image&quot; width=&quot;30px&quot;&gt;<br>//简化<br>&lt;img :src=&quot;item.image&quot; width=&quot;30px&quot;&gt;<br></code></pre></td></tr></table></figure></li><li>v-if &#x2F; v-else-if &#x2F; v-else：条件性的渲染某元素，判定为true时渲染，否则不渲染<ul><li>语法：<span style="color:#FF6B6B">v-if&#x3D;”表达式”</span>，表达式值为true，显示；false，隐藏</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;span v-if=&quot;gender==1&quot;&gt;男生&lt;/span&gt;<br>&lt;span v-else-if=&quot;gender==2&quot;&gt;女生&lt;/span&gt;<br>&lt;span v-else&gt;未知&lt;/span&gt;<br></code></pre></td></tr></table></figure><ul><li>原理：基于条件判断来控制创建或移除元素节点（条件渲染）</li><li>场景：要么显示，要么不显示，不频繁切换的场景</li></ul></li></ul><p><span style="color:#FF6B6B">注：v-else-if 必须出现在 v-if 之后，可以出现多个；v-else 必须出现在 v-if &#x2F; v-else-if 之后</span></p><ul><li>v-show：根据条件展示某元素，区别在于切换的是display属性的值<ul><li>语法：<span style="color:#FF6B6B">v-show&#x3D;”表达式”</span>，表达式值为true，显示；false，隐藏</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;span v-show=&quot;gender==1&quot;&gt;男生&lt;/span&gt;<br></code></pre></td></tr></table></figure><ul><li>原理：基于CSS样式display来控制显示与隐藏</li><li>场景：频繁切换显示隐藏的场景</li></ul></li><li>v-model：在表单元素上创建双向数据绑定，可以方便的获取或设置表单项数据<ul><li>语法：<span style="color:#FF6B6B">v-model&#x3D;”变量名”</span></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input type=&quot;text&quot; id=&quot;name&quot; v-model=&quot;searchForm.name&quot;&gt;<br></code></pre></td></tr></table></figure></li></ul><p><span style="color:#FF6B6B">注：v-model中绑定的变量必须在data中定义</span></p><ul><li>v-on：为HTML标签绑定事件（添加事件监听）<ul><li>语法：<span style="color:#FF6B6B">v-on:事件名&#x3D;”方法名”</span>，可简化为：<span style="color:#FF6B6B">@事件名&#x3D;”方法名”</span></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div id=&quot;app&quot;&gt;<br>&lt;button type=&quot;button&quot; v-on:click=&quot;handle&quot;&gt;点我&lt;/button&gt;<br>&lt;button type=&quot;button&quot; @click=&quot;handle&quot;&gt;再点我&lt;/button&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><ul><li>在Vue中定义方法：</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">const app = createApp(&#123;<br>data()&#123;<br>//...    <br>&#125;,<br>methods:&#123;<br>handle()&#123;<br>console.log(&#x27;试试就试试&#x27;);                    <br>&#125;    <br>&#125;<br>&#125;).mount(&quot;#app&quot;)<br></code></pre></td></tr></table></figure></li></ul><p><span style="color:#FF6B6B">注：methods属性中的this指向Vue实例，可以通过this获取到data中定义的数据</span></p><h3 id="5-Ajax："><a href="#5-Ajax：" class="headerlink" title="5.Ajax："></a>5.Ajax：</h3><ul><li>介绍：异步的JavaScript和XML</li><li>XML：可扩展标记语言，本质是一种数据格式，可以用来存储复杂的数据结构</li><li>作用：<ul><li>数据交换：通过Ajax可以给服务器发送请求，并获取服务器响应的数据</li><li>异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用的校验等</li></ul></li></ul><h3 id="6-Axios："><a href="#6-Axios：" class="headerlink" title="6.Axios："></a>6.Axios：</h3><ul><li><p>介绍：Axios对原生的Ajax进行了封装，简化书写，快速开发</p></li><li><p>步骤：</p><ul><li>引入Axios的js文件（参考官网）</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>使用Axios发送请求，并获取响应结果<ul><li>method：请求方式，GET&#x2F;POST</li><li>url：请求路径</li><li>data：请求数据（POST）</li><li>params：发送请求时携带的url参数，如：…?key&#x3D;val</li></ul></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">axios(&#123;<br>method: &#x27;GET&#x27;,<br>url: &#x27;https://web-server.itheima.net/emps/list&#x27;<br>&#125;).then((result) =&gt;&#123; //成功回调函数<br>console.log(result.data);<br>&#125;).catch((err) =&gt;&#123; //失败回调函数<br>alert(err);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>Axios-请求方式别名（推荐使用）：</p><ul><li>为了方便起见，Axios已经为所有支持的请求方法提供了别名</li><li>格式：axios.请求方式(url [, data [, config]])</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">//GET请求<br>axios.get(&#x27;https://mock.apifox.cn/mq/3083103-0-default/emps/list&#x27;).then((result) =&gt;&#123;<br>    console.log(result.data);<br>&#125;).catch((err) =&gt;&#123;<br>    console.log(err);<br>&#125;);<br>//POST请求<br>axios.post(&#x27;https://mock.apifox.cn/mq/3083103-0-default/emps/update&#x27;,&#x27;id=1&#x27;).then((result) =&gt;&#123;<br>    console.log(result.data);<br>&#125;).catch((err) =&gt;&#123;<br>    console.log(err);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="7-async-await"><a href="#7-async-await" class="headerlink" title="7.async &amp; await"></a>7.async &amp; await</h3><ul><li>作用：可以通过async、await可以让异步变为同步操作。async就是来声明一个异步方法，await是用来等待异步任务执行（提高代码可读性和可维护性）</li><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">methods:&#123;<br>    async search()&#123;<br>        let result = await axios.get(&#x27;https://web-server.itheima.net/emps/list?name=xxx&amp;gender=xxx&amp;job=xxx&#x27;);<br>        this.employees = result.data.data;    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><span style="color:#FF6B6B">注：await关键字只在async函数内有效，await关键字取代then函数，等待获取到请求成功的结果值</span></p><h3 id="8-Vue生命周期"><a href="#8-Vue生命周期" class="headerlink" title="8.Vue生命周期"></a>8.Vue生命周期</h3><ul><li>生命周期：指一个对象从创建到销毁的整个过程</li><li>生命周期的八个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法（钩子）<ul><li>beforeCreate：创建前</li><li>created：创建后</li><li>beforeMount：载入前</li><li>mounted：挂载完成</li><li>beforeUpdate：数据更新前</li><li>updated：数据更新后</li><li>beforeUnmount：组件销毁前</li><li>unmounted：组件销毁后</li></ul></li></ul><img src="/2025/02/12/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.jpg" class=""><ul><li>钩子函数使用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script type=&quot;module&quot;&gt;<br>    import &#123; createApp &#125; from &#x27;https://.../vue.esm-browser.js&#x27;<br>    const app = createApp(&#123;<br>        data()&#123;<br>            return &#123;<br>                message:&quot;Hello Vue&quot;<br>            &#125;        <br>        &#125;,<br>        //生命周期-钩子函数 mounted<br>        mounted()&#123;<br>            console.log(&#x27;Vue挂载完毕，发送请求获取数据...&#x27;);        <br>        &#125;    <br>    &#125;).mount(&quot;#app&quot;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><span style="color:#FF6B6B">注：钩子函数与 data 或 methods 是齐平的</span></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>JavaScript</tag>
      
      <tag>Ajax</tag>
      
      <tag>Axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lombok库</title>
    <link href="/2025/01/28/Lombok%E5%BA%93/"/>
    <url>/2025/01/28/Lombok%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ul><li>Lombok是一个Java库，通过注解的方式简化Java代码的编写，减少样板代码，提高开发效率。它通过注解处理器在编译时自动生成代码，如getter&#x2F;setter、构造函数、equals&#x2F;hashCode等方法。</li><li>优点：<ul><li>减少样板代码，使类更简洁</li><li>提高开发效率</li><li>自动生成的代码更规范</li><li>减少人为错误</li></ul></li></ul><h2 id="二、常用注解"><a href="#二、常用注解" class="headerlink" title="二、常用注解"></a>二、常用注解</h2><h4 id="1-简化POJO类"><a href="#1-简化POJO类" class="headerlink" title="1.简化POJO类"></a>1.简化POJO类</h4><p>(1) <strong>@Data</strong>：</p><ul><li>是一个复合注解，包含以下功能：</li><li>自动生成所有字段的 getter 方法</li><li>生成非 final 字段的 setter 方法</li><li>生成 equals() 和 hashCode() 方法</li><li>生成 toString() 方法</li><li>相当于 @Getter @Setter @ToString @EqualsAndHashCode 的组合</li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) <strong>@NoArgsConstructor</strong>：</p><ul><li>自动生成无参构造函数</li><li>如果类中有 final 字段且未初始化，需要配合 @NoArgsConstructor(force &#x3D; true) 使用</li><li>force&#x3D;true时会给final字段赋默认值(null&#x2F;0&#x2F;false)</li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name; <span class="hljs-comment">// 编译错误，需要@NoArgsConstructor(force = true)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(3) <strong>@AllArgsConstructor</strong>：</p><ul><li>自动生成包含所有字段的构造函数</li><li>字段顺序与类中声明的顺序一致</li><li>不包含static和final未初始化的字段</li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> price;<br>&#125;<br><span class="hljs-comment">// 等效于：</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Product</span><span class="hljs-params">(Long id, String name, <span class="hljs-type">double</span> price)</span> &#123;<br>    <span class="hljs-built_in">this</span>.id = id;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.price = price;<br>&#125;<br></code></pre></td></tr></table></figure><p>(4) <strong>@RequiredArgsConstructor</strong>：</p><ul><li>生成包含特定字段的构造函数</li><li>包含final字段和带有@NonNull注解的未初始化字段</li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long orderId;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-keyword">private</span> String customerName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> amount;<br>&#125;<br><span class="hljs-comment">// 生成的构造函数：</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(Long orderId, String customerName)</span> &#123;<br>    <span class="hljs-built_in">this</span>.orderId = orderId;<br>    <span class="hljs-built_in">this</span>.customerName = customerName;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-简化资源管理"><a href="#2-简化资源管理" class="headerlink" title="2.简化资源管理"></a>2.简化资源管理</h4><p>(1) <strong>@Cleanup</strong>：</p><ul><li>自动管理资源关闭</li><li>用于需要关闭的资源对象（如IO流、数据库连接等）</li><li>在变量作用域结束时自动调用close()方法</li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyFile</span><span class="hljs-params">(String src, String dest)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-meta">@Cleanup</span> <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>    <span class="hljs-meta">@Cleanup</span> <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dest);<br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-keyword">while</span> ((length = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>        out.write(buffer, <span class="hljs-number">0</span>, length);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 无需手动调用 in.close() 和 out.close()</span><br></code></pre></td></tr></table></figure><h4 id="3-简化日志配置"><a href="#3-简化日志配置" class="headerlink" title="3. 简化日志配置"></a>3. 简化日志配置</h4><p>(1) <strong>@Slf4j</strong>：</p><ul><li>自动生成SLF4J日志对象</li><li>变量名为log</li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processOrder</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;Processing order...&quot;</span>); <span class="hljs-comment">// 直接使用log对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 其他日志注解：</p><img src="/2025/01/28/Lombok%E5%BA%93/1.jpg" class="">  <h4 id="4-其他实用功能"><a href="#4-其他实用功能" class="headerlink" title="4. 其他实用功能"></a>4. 其他实用功能</h4><p>(1) <strong>@Builder</strong>：</p><ul><li>实现建造者模式</li><li>生成builder()静态方法</li><li>支持设置默认值（@Builder.Default）</li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Builder</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-meta">@Builder</span>.Default<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;default&quot;</span>;<br>&#125;<br><span class="hljs-comment">// 使用方式：</span><br><span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> Product.builder()<br>    .id(<span class="hljs-number">1L</span>)<br>    .build(); <span class="hljs-comment">// name默认为&quot;default&quot;</span><br></code></pre></td></tr></table></figure><p>(2) <strong>@SneakyThrows</strong>：</p><ul><li>偷偷抛出受检异常（无需声明throws）</li><li>常用于不想处理受检异常的场景</li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SneakyThrows(IOException.class)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">readFile</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-keyword">return</span> Files.readString(Paths.get(path));<br>&#125;<br><span class="hljs-comment">// 调用处不需要处理IOException</span><br></code></pre></td></tr></table></figure><p>(3) <strong>@Synchronized</strong>：</p><ul><li>方法级同步的更安全实现</li><li>比synchronized关键字更细粒度</li><li>生成私有锁对象避免死锁</li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-meta">@Synchronized</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程安全操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(4) <strong>@Value</strong>：</p><ul><li>创建不可变类（所有字段默认final）</li><li>包含@Getter、@ToString、@EqualsAndHashCode等</li><li>不生成setter</li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImmutablePoint</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;<br><span class="hljs-comment">// 生成的类相当于：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImmutablePoint</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> y;<br>    <span class="hljs-comment">// 只有getter，没有setter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(5) <strong>@With</strong>：</p><ul><li>创建对象的不可变副本并修改指定字段</li><li>适用于不可变对象的”修改”操作</li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@With</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br><span class="hljs-comment">// 使用方式：</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> p1.withAge(<span class="hljs-number">31</span>); <span class="hljs-comment">// 创建新对象，只修改age</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Lombok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/2025/01/25/Maven/"/>
    <url>/2025/01/25/Maven/</url>
    
    <content type="html"><![CDATA[<h2 id="1-介绍："><a href="#1-介绍：" class="headerlink" title="1.介绍："></a>1.介绍：</h2><ul><li>Maven是一款用于管理和构建Java项目的工具，是apache旗下的一个开源项目</li><li>官网：<a href="http://maven.apache.org/">http://maven.apache.org/</a></li></ul><img src="/2025/01/25/Maven/1.jpg" class=""><ul><li>仓库：用于存储资源，管理各种jar包<ul><li>本地仓库：自己计算机上的一个目录</li><li>中央仓库：由Maven团队维护的，全球唯一的。仓库地址：<a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></li><li>远程仓库（私服）：一般由公司团队搭建的私有仓库</li></ul><p>  <span style="color:#FF6B6B">注：查找依赖（jar）的顺序：本地仓库 -&gt; 远程仓库 -&gt; 中央仓库</span></p></li></ul><h2 id="2-作用："><a href="#2-作用：" class="headerlink" title="2.作用："></a>2.作用：</h2><ul><li>依赖管理：方便快捷的管理项目依赖的资源（jar包）</li><li>项目构建：标准化的跨平台（Linux、windows、MacOS）的自动化项目构建方式</li><li>统一项目结构：提供标准、统一的项目结构</li></ul><h2 id="3-安装："><a href="#3-安装：" class="headerlink" title="3.安装："></a>3.安装：</h2><p>（1）解压 apache-maven-3.9.4-bin.zip<br>（2）配置本地仓库：修改 conf&#x2F;settings.xml 中的&lt; localRepository &gt;为一个指定目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>目录路径<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）配置阿里云私服：修改 conf&#x2F;settings.xml 中的&lt; mirrors &gt;标签，为其添加如下子标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（4）配置环境变量：MAVEN_HOME 为maven的解压目录，并将其bin目录加入PATH环境变量</p><h2 id="4-坐标："><a href="#4-坐标：" class="headerlink" title="4.坐标："></a>4.坐标：</h2><ul><li>简介：<ul><li>Maven 中的坐标是资源（jar）的唯一标识，通过该坐标可以唯一定位资源位置</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul></li><li>主要组成：<ul><li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，如com.baidu）</li><li>artifactId：定义当前Maven项目名称（通常是模块名称）</li><li>version：定义当前项目版本号<ul><li>SNAPSHOT：功能不稳定、尚处于开发中的版本，即快照版本</li><li>RELEASE：功能趋于稳定、当前更新停止，可以用于发行的版本</li></ul></li></ul></li></ul><h2 id="5-导入Maven项目："><a href="#5-导入Maven项目：" class="headerlink" title="5.导入Maven项目："></a>5.导入Maven项目：</h2><ul><li>建议将要导入的maven项目复制到你的项目目录下</li><li>建议选择maven项目的pom.xml文件进行导入</li></ul><h2 id="6-依赖管理："><a href="#6-依赖管理：" class="headerlink" title="6.依赖管理："></a>6.依赖管理：</h2><ul><li>依赖配置：<ul><li>依赖：指当前项目运行所需要的jar包，一个项目中可以引入多个依赖</li><li>配置：<ul><li>在 pom.xml 中编写&lt; dependencies &gt;标签</li><li>在&lt; dependencies &gt;标签中使用&lt; dependency &gt;引入坐标</li><li>定义坐标的 groupId, artifactId, version</li><li>点击刷新按钮，引入最新加入的坐标</li></ul></li></ul><p>  <span style="color:#FF6B6B">注：如果不知道依赖的坐标信息，可以到 <a href="https://mvnrepository.com/">https://mvnrepository.com/</a> 中搜索</span></p><ul><li>排除依赖：<ul><li>简介：指主动断开依赖的资源，被排除的资源无需指定版本</li><li>配置：<ul><li>&lt; dependency &gt;编写&lt; exclusions &gt;标签</li><li>在&lt; exclusions &gt;标签中使用&lt; exclusion &gt;引入坐标</li><li>定义坐标的 groupId, artifactId（无需指定版本）</li></ul></li></ul></li></ul><p>  <span style="color:#FF6B6B">注：一旦依赖配置变更了，需要重新加载；引入的依赖如果本地仓库不存在，需要联网下载</span></p></li><li>生命周期：<ul><li>作用：为了对所有的maven项目构建过程进行抽象和统一</li><li>三套相互独立的生命周期：<ul><li>clean：清理工作</li><li>default：核心工作：如：编译、测试、打包、安装、部署等</li><li>site：生成报告、发布站点等</li></ul></li><li>阶段<ul><li>每套生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段</li><li>重要阶段：<ul><li>clean：移除上一次构建生成的文件</li><li>compile：编译项目源代码</li><li>test：使用合适的单元测试框架运行测试（junit）</li><li>package：将编译后的文件打包，如：jar、war等</li><li>install：安装项目到本地仓库</li></ul></li></ul></li></ul><p>  <span style="color:#FF6B6B">注：在<span style="color:red">同一套</span>生命周期中，当运行后面的阶段时，前面的阶段都会运行</span></p><ul><li>执行指定生命周期的两种方式：<ul><li>在idea中，右侧的maven工具栏，选中对应的生命周期，双击执行</li><li>在命令行中，通过命令执行（如：mvn clean）</li></ul></li></ul></li></ul><h2 id="7-测试："><a href="#7-测试：" class="headerlink" title="7.测试："></a>7.测试：</h2><ul><li>作用：用来促进鉴定软件的正确性、完整性、安全性和质量的过程</li><li>阶段划分：<ul><li>单元测试：<ul><li>介绍：对软件的基本组成单位进行测试，最小测试单位</li><li>目的：检验软件基本组成单位的正确性</li><li>测试人员：开发人员</li></ul></li><li>集成测试：<ul><li>介绍：将已分别通过测试的单元，按设计要求组合成系统或子系统，再进行的测试</li><li>目的：检查单元之间的协作是否正确</li><li>测试人员：开发人员</li></ul></li><li>系统测试：<ul><li>介绍：对已经集成好的软件系统进行彻底的测试</li><li>目的：验证软件系统的正确性、性能是否满足指定的要求</li><li>测试人员：测试人员</li></ul></li><li>验收测试：<ul><li>介绍：交付测试，是针对用户需求、业务流程进行的正式测试</li><li>目的：验证软件系统是否满足验收标准</li><li>测试人员：客户&#x2F;需求方</li></ul></li></ul></li><li>测试方法：<ul><li>白盒测试：<ul><li>清楚软件内部结构、代码逻辑</li><li>用于验证代码、逻辑正确性</li></ul></li><li>黑盒测试：<ul><li>不清楚软件内部结构、代码逻辑</li><li>用于验证软件功能、兼容性等方面</li></ul></li><li>灰盒测试：<ul><li>结合了白盒测试和黑盒测试的特点，既关注软件的内部结构又考虑外部表现（功能）</li></ul></li></ul></li></ul><h2 id="8-单元测试："><a href="#8-单元测试：" class="headerlink" title="8.单元测试："></a>8.单元测试：</h2><ul><li>介绍：针对最小的功能单元（方法），编写测试代码对其正确性进行测试</li><li>JUnit：最流行的Java测试框架之一，提供了一些功能，方便程序进行单元测试</li><li>main方法测试：<ul><li>测试代码与源代码未分开，难维护</li><li>一个方法测试失败，影响后面方法</li><li>无法自动化测试，得到测试报告</li></ul></li><li>JUnit单元测试：<ul><li>测试代码与源代码分开，便于维护</li><li>可根据需要进行自动化测试</li><li>可自动分析测试结果，产出测试报告</li></ul></li></ul><p><span style="color:#FF6B6B">注：JUnit单元测试类名命名规范为：XxxxxTest【规范】；JUnit单元测试的方法必须声明为public void【规定】</span></p><ul><li>断言：<ul><li>JUnit提供了一些辅助方法，用来帮我们确定被测试的方法是否按照预期的效果正常工作，这种方式称为断言</li><li>单元测试方法运行不报错，不代表业务方法没问题</li><li>通过断言可以检测方法运行结果是否和预期一致，从而判断业务方法的正确性</li></ul></li></ul><img src="/2025/01/25/Maven/2.jpg" class=""><p><span style="color:#FF6B6B">注：上述方法形参中的最后一个参数msg表示错误提示信息，可以不指定（有对应的重载方法）</span></p><ul><li>常见注解：</li></ul><img src="/2025/01/25/Maven/3.jpg" class=""><p><span style="color:#FF6B6B">注：通过@ParameterizedTest进行参数化测试时，需要@ValueSource进行参数设置，并且在单元测试方法上声明方法形参。如下所示：</span></p><img src="/2025/01/25/Maven/4.jpg" class=""><ul><li>企业开发规范：<ul><li>原则：编写测试方法时，要尽可能的覆盖业务方法中所有可能的情况（尤其是边界值）</li></ul></li><li>依赖范围：<ul><li>依赖的jar包默认情况下可以在任何地方使用。可以通过&lt; scope &gt;…&lt; &#x2F;scope &gt;设置其作用范围</li></ul>  <img src="/2025/01/25/Maven/5.jpg" class=""><ul><li>作用范围：<ul><li>主程序范围有效（main文件夹范围内）</li><li>测试程序范围有效（test文件夹范围内）</li><li>是否参与打包运行（package指令范围内）</li></ul></li><li>常见取值：<ul><li>compile（默认）：主程序、测试程序、打包（运行）都有效</li><li>test：仅测试有效</li><li>provided：主程序、测试程序有效</li><li>runtime：测试程序、打包（运行）有效</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web基础</title>
    <link href="/2025/01/15/Web%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/01/15/Web%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h4 id="1-静态资源："><a href="#1-静态资源：" class="headerlink" title="1.静态资源："></a>1.静态资源：</h4><ul><li>服务器上存储的不会改变的数据，通常不会根据用户的请求而变化。比如：HTML、CSS、JS、图片、视频等（负责页面展示）</li></ul><h4 id="2-动态资源："><a href="#2-动态资源：" class="headerlink" title="2.动态资源："></a>2.动态资源：</h4><ul><li>服务器根据用户请求和其他数据动态生成的，内容可能会在每次请求时都发生变化。比如：Spring框架等（负责逻辑处理）</li></ul><h4 id="3-B-S-架构："><a href="#3-B-S-架构：" class="headerlink" title="3.B&#x2F;S 架构："></a>3.B&#x2F;S 架构：</h4><ul><li>Browser&#x2F;Server，浏览器&#x2F;服务器架构模式。客户端只需浏览器，应用程序的逻辑和数据都存在服务器端（维护方便 体验一般）</li></ul><h4 id="4-C-S-架构："><a href="#4-C-S-架构：" class="headerlink" title="4.C&#x2F;S 架构："></a>4.C&#x2F;S 架构：</h4><ul><li>Client&#x2F;Server，客户端&#x2F;服务器架构模式。需要单独开发维护客户端（体验不错 开发维护麻烦）</li></ul><h2 id="二、HTTP协议"><a href="#二、HTTP协议" class="headerlink" title="二、HTTP协议"></a>二、HTTP协议</h2><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a>1.概念：</h4><ul><li>超文本传输协议，规定了浏览器和服务器之间数据传输的规则</li></ul><h4 id="2-特点："><a href="#2-特点：" class="headerlink" title="2.特点："></a>2.特点：</h4><ul><li>基于TCP协议：面向连接，安全</li><li>基于请求-响应模型：一次请求对应一次响应</li><li>HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的<ul><li>缺点：多次请求间不能共享数据</li><li>优点：速度快</li></ul></li></ul><h4 id="3-请求协议："><a href="#3-请求协议：" class="headerlink" title="3.请求协议："></a>3.请求协议：</h4><ul><li>请求数据格式：<ul><li>请求行：请求数据第一行，包含请求方式、资源路径、协议</li><li>请求头：第二行开始，格式 key:value<ul><li>常见请求头</li></ul>  <img src="/2025/01/15/Web%E5%9F%BA%E7%A1%80/1.jpg" class=""></li><li>请求体：POST请求存放请求参数<ul><li>请求方式-GET：请求参数在请求行中，没有请求体，GET请求大小在浏览器中是有限制的</li><li>请求方式-POST：请求参数在请求体中，POST请求大小是没有限制的</li></ul></li></ul></li></ul><p><span style="color:#FF6B6B">注：请求头和请求体之间有一个空行</span></p><ul><li>请求数据获取：<ul><li>Web服务器（Tomcat）对HTTP协议的请求数据进行解析，并进行了封装（HttpServletRequest），在调用Controller方法的时候传递给了该方法</li><li>获取方法：</li></ul>  <img src="/2025/01/15/Web%E5%9F%BA%E7%A1%80/2.jpg" class=""></li></ul><h4 id="4-响应协议："><a href="#4-响应协议：" class="headerlink" title="4.响应协议："></a>4.响应协议：</h4><ul><li>响应数据格式：<ul><li>响应行：响应数据第一行，包含协议、状态码、描述<ul><li>状态码：</li></ul>  <img src="/2025/01/15/Web%E5%9F%BA%E7%A1%80/3.jpg" class=""></li><li>响应头：第二行开始，格式 key:value<ul><li>常见响应头</li></ul>  <img src="/2025/01/15/Web%E5%9F%BA%E7%A1%80/4.jpg" class=""></li><li>响应体：最后一部分，存放响应数据</li></ul></li></ul><p><span style="color:#FF6B6B">注：响应头和响应体之间有一个空行</span></p><ul><li>响应数据设置：<ul><li>Web服务器对HTTP协议的响应数据进行了封装（HttpServletResponse），并在调用Controller方法的时候传递给了该方法</li><li>设置方法：<ul><li>方法一：</li></ul>  <img src="/2025/01/15/Web%E5%9F%BA%E7%A1%80/5.jpg" class=""><ul><li>方法二：</li></ul>  <img src="/2025/01/15/Web%E5%9F%BA%E7%A1%80/6.jpg" class=""></li></ul></li></ul><h4 id="5-其他："><a href="#5-其他：" class="headerlink" title="5.其他："></a>5.其他：</h4><ul><li>静态资源文件存放位置（SpringBoot项目）：<ul><li>resources&#x2F;static</li></ul></li><li>@ResponseBody注解作用：<ul><li>@RestController &#x3D; @Controller + @ResponseBody</li><li>将controller方法的返回值直接写入HTTP响应体</li><li>如果是对象或集合，会先转为json，再响应</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端基础</title>
    <link href="/2025/01/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/01/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Web组成："><a href="#1-Web组成：" class="headerlink" title="1.Web组成："></a>1.Web组成：</h2><ul><li>HTML：负责网页的结构（页面元素和内容）</li><li>CSS：负责网页的表现（页面元素的外观、位置等页面样式，如：颜色、大小等）</li><li>JavaScript：负责网页的行为（交互效果）</li></ul><h2 id="2-HTML：超文本标记语言"><a href="#2-HTML：超文本标记语言" class="headerlink" title="2.HTML：超文本标记语言"></a>2.HTML：超文本标记语言</h2><h4 id="1-介绍："><a href="#1-介绍：" class="headerlink" title="(1) 介绍："></a>(1) 介绍：</h4><ul><li>超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容</li><li>标记语言：由标签”&lt;标签名&gt;”构成的语言<ul><li>HTML标签都是预定义好的。例如：使用&lt; h1 &gt;展示标题，使用&lt; img &gt;展示图片，使用&lt; video &gt;展示视频</li><li>HTML代码直接在浏览器中运行，HTML标签由浏览器解析</li></ul></li></ul><h4 id="2-入门："><a href="#2-入门：" class="headerlink" title="(2) 入门："></a>(2) 入门：</h4><ul><li><p>新建文本文件，后缀名改为.html</p></li><li><p>编写HTML的基本骨架，定义标题</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>HTML快速入门<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <br>   <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>&lt; head &gt;&lt; &#x2F;head &gt;：网页头部，用来存放给浏览器看的信息，如：CSS样式</li><li>&lt; body &gt;&lt; &#x2F;body &gt;：网页主体，用来存放给用户看的信息，如：文字、图片、视频</li><li>&lt; title &gt;&lt; &#x2F;title &gt;：网页标题</li></ul></li><li><p>在&lt; body &gt;中填写内容</p></li></ul><p><span style="color:#FF6B6B">注：标签名不区分大小写</span></p><h4 id="3-常见标签："><a href="#3-常见标签：" class="headerlink" title="(3) 常见标签："></a>(3) 常见标签：</h4><ul><li>&lt; h1 &gt;&lt; &#x2F;h1 &gt;：一级标题标签（h1-h6：总共6个标题标签，h6级别最低）</li><li>&lt; a &gt;&lt; &#x2F;a &gt;：超链接标签<ul><li>href：链接地址</li><li>target：打开方式<ul><li>_blank：新窗口打开</li><li>_self：本窗口打开（默认）</li></ul></li></ul></li><li>&lt; span &gt;&lt; &#x2F;span &gt;：没有语义的标签，布局标签</li><li>&lt; div &gt;&lt; &#x2F;div &gt;：没有语义的标签，布局标签<ul><li>&lt; div &gt;标签：一个只显示一个（独占一行）；宽度默认是父元素的宽度，高度默认由内容撑开；可以设置宽高（width、height）</li><li>&lt; span &gt;标签：一行可以显示多个；宽度和内容默认由内容撑开；不可以设置宽高（width、height）</li></ul></li><li>&lt; video &gt;&lt; &#x2F;video &gt;：视频标签<ul><li>src：视频地址</li><li>controls：显示播放控件</li><li>autoplay：自动播放</li><li>width：视频宽度（建议：宽度和高度只设置一个即可，另一个会等比例缩放）</li><li>height：视频高度<ul><li>单位：<ul><li>px：像素</li><li>%：百分比（相当于父元素的百分比）</li></ul></li></ul></li></ul></li><li>&lt; audio &gt;&lt; &#x2F;audio &gt;：音频标签<ul><li>src：音频地址</li><li>controls：显示播放控件</li></ul></li><li>&lt; p &gt;&lt; &#x2F;p &gt;：段落标签</li><li>&lt; br &gt;：换行</li><li>&lt; img &gt;：图片标签<ul><li>src：图片的访问地址<ul><li>绝对路径<ul><li>绝对磁盘路径</li><li>绝对网络路径</li></ul></li><li>相对路径<ul><li>.&#x2F;：当前目录（可以省略）</li><li>..&#x2F;：上一级目录</li></ul></li></ul></li></ul></li><li>&lt; b &gt;&lt; &#x2F;b &gt;：加粗文本标签，语义上无特殊含义（只是视觉上加粗）</li><li>&lt; strong &gt;&lt; &#x2F;strong &gt;：加粗文本标签，语义上表示强调，可能被搜索引擎视为重要内容，屏幕阅读器可能加重语气朗读</li><li>&lt; u &gt;&lt; &#x2F;u &gt;：下划线标签</li><li>&lt; ins &gt;&lt; &#x2F;ins &gt;：下划线标签，语义上表示强调</li><li>&lt; i &gt;&lt; &#x2F;i &gt;：字体倾斜标签</li><li>&lt; em &gt;&lt; &#x2F;em &gt;：字体倾斜标签，语义上表示强调</li><li>&lt; s &gt;&lt; &#x2F;s &gt;：删除线标签（在字体中间加条横线）</li><li>&lt; del &gt;&lt; &#x2F;del &gt;：删除线标签，语义上表示强调</li></ul><p><span style="color:#FF6B6B">注：HTML页面在渲染展示的时候，是从上往下逐行解析展示的</span></p><h4 id="4-特殊字符实体："><a href="#4-特殊字符实体：" class="headerlink" title="(4) 特殊字符实体："></a>(4) 特殊字符实体：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-symbol">&amp;nbsp;</span> ：不换行空格<br>- 普通空格（按键盘空格键）在 HTML 中会被合并成一个<br>- <span class="hljs-symbol">&amp;nbsp;</span> 不会被合并，每个都会显示为一个空格<br><span class="hljs-symbol">&amp;ensp;</span> ：半角空格（1个字符宽度）<br><span class="hljs-symbol">&amp;emsp;</span> ：全角空格（2个字符宽度）<br><span class="hljs-symbol">&amp;thinsp;</span> ：窄空格（小于半角）<br><span class="hljs-symbol">&amp;lt;</span> ：&lt;<br><span class="hljs-symbol">&amp;gt;</span> ：&gt;<br></code></pre></td></tr></table></figure><h4 id="5-表单标签："><a href="#5-表单标签：" class="headerlink" title="(5) 表单标签："></a>(5) 表单标签：</h4><ul><li><p>表单：在网页中主要负责数据采集功能，如注册、登录等数据采集</p></li><li><p>标签：&lt; form &gt;</p></li><li><p>表单项：不同类型的input元素、下拉列表、文本域等</p></li><li><p>&lt; input &gt;：定义表单项，通过type属性控制输入形式（text&#x2F;password&#x2F;…）</p></li><li><p>&lt; select &gt;：定义下拉列表</p></li><li><p>&lt; textarea &gt;：定义文本域（大型输入框）</p></li><li><p>属性：</p><ul><li>action：规定当提交表单时向何处发送表单数据（URL）</li><li>method：规定用于发送表单数据的方式（GET、POST）<ul><li>GET：默认，表单数据会出现在URL后面（不安全，大小有限，不适合提交大数据量的表单）</li><li>POST：表单数据会在消息体&#x2F;请求体中提交到服务器（安全，大小没有限制）</li></ul></li></ul></li><li><p>&lt; input &gt;：</p><ul><li>type取值：<ul><li>text：默认值，定义单行的输入字段</li><li>password：定义密码字段</li><li>radio：定义单选按钮</li><li>checkbox：定义复选框</li><li>file：定义文件上传按钮</li><li>date &#x2F; time &#x2F; datetime-local：定义日期 &#x2F; 时间 &#x2F; 日期时间</li><li>hidden：定义隐藏域（看不见，但提交时会提交）</li><li>submit &#x2F; reset &#x2F; button：定义提交按钮 &#x2F; 重置按钮 &#x2F; 可点击按钮（还可以用&lt; button &gt;）</li></ul></li><li><span style="color:#FF6B6B">注：</span><ul><li><span style="color:#FF6B6B">单选框如果是同一组其表单项名字（name）需要一样（复选框也一样）</span></li><li><span style="color:#FF6B6B">单选框和复选框的value属性代表最后提交的值</span></li></ul></li></ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">性别：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span> 男<br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span> 女 <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>&lt; label &gt;：</p><ul><li>是 HTML 中用于 关联表单控件（如输入框、复选框等）的标签，主要作用是提升用户体验和可访问性。当用户点击 &lt; label &gt; 时，浏览器会自动聚焦到对应的表单元素。</li></ul></li><li><p>&lt; select &gt;：</p><ul><li>使用&lt; option &gt;定义列表项</li></ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">学历：<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;degree&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>---------请选择---------<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>大专<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>本科<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>硕士<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>博士<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><span style="color:#FF6B6B">注：表单项要想能够采集数据，必须得设置name属性，表示当前表单项的名字</span></p><h4 id="6-表格标签："><a href="#6-表格标签：" class="headerlink" title="(6) 表格标签："></a>(6) 表格标签：</h4><ul><li>标签：<ul><li>&lt; table &gt;：定义表格整体</li><li>&lt; thead &gt;：定义表格头部（可选）</li><li>&lt; tbody &gt;：定义表格中主体部分（可选）</li><li>&lt; tr &gt;：表格的行，可以包裹多个&lt; td &gt;</li><li>&lt; td &gt;：表格单元格(普通)，可以包裹内容；如果是表头单元格，可以替换为&lt; th &gt;</li></ul></li></ul><h2 id="3-CSS：层叠样式表"><a href="#3-CSS：层叠样式表" class="headerlink" title="3.CSS：层叠样式表"></a>3.CSS：层叠样式表</h2><h4 id="1-引入方式："><a href="#1-引入方式：" class="headerlink" title="(1) 引入方式："></a>(1) 引入方式：</h4><ul><li>行内样式：写在标签的style属性中（配合JavaScript使用）</li><li>内部样式：写在style标签中（可以写在页面任何位置，但通常约定写在head标签中）</li><li>外部样式：写在一个单独的.css文件中（需要通过link标签在网页中引入）</li></ul><h4 id="2-颜色表示形式："><a href="#2-颜色表示形式：" class="headerlink" title="(2) 颜色表示形式："></a>(2) 颜色表示形式：</h4><ul><li>关键字：颜色英文单词，如red、green</li><li>rgb表示法：rgb(r,g,b)，红绿蓝三原色，取值0-255，如rgb(0,0,0)、rgb(255,0,0)</li><li>rgba表示法：rgba(r,g,b,a)，红绿蓝三原色，a表示透明度，取值0-1，如rgba(0,0,0,0.3)、rgba(255,0,0,0.5)</li><li>十六进制表示法：#rrggbb，#开头，将数字转换成十六进制表示，如#000000、#ff0000，每个颜色通道的两位十六进制值相同时可简写，如#ff0000可以简写为#f00</li></ul><h4 id="3-CSS选择器："><a href="#3-CSS选择器：" class="headerlink" title="(3) CSS选择器："></a>(3) CSS选择器：</h4><ul><li>元素选择器：元素名称{…}，如h1{…}，即选择页面上所有的&lt; h1 &gt;标签</li><li>类选择器：.class属性值{…}，如.cls{…}，即选择页面上所有class属性为cls的标签</li><li>id选择器：#id属性值{…}，如#hid{…}，即选择页面上id属性为hid的标签</li></ul><p><span style="color:#FF6B6B">注：如果三个选择器匹配到同一个标签：id选择器&gt;类选择器&gt;元素选择器</span></p><h4 id="4-常见属性："><a href="#4-常见属性：" class="headerlink" title="(4) 常见属性："></a>(4) 常见属性：</h4><ul><li>text-decoration:none; ：去除超链接下方的下划线</li><li>color:#b2b2b2; ：设置颜色</li><li>line-height:2; ：设置行高，这里是2倍行高</li><li>text-indent:2em; ：设置首行缩进，这里是首行缩进2个字符</li></ul><h4 id="5-盒子模型："><a href="#5-盒子模型：" class="headerlink" title="(5) 盒子模型："></a>(5) 盒子模型：</h4><ul><li>组成：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin）  <img src="/2025/01/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/1.jpg" class=""></li><li>布局：会使用 div 和 span 这两个没有语义的布局标签（通常是div）</li><li>使用：<ul><li>padding:20px 30px 40px 50px;（上：20px  右：30px  下：40px  左：50px，即顺时针）</li><li>padding:20px 30px;（上下：20px  左右：30px）</li><li>padding:20px;（上下左右：20px）</li><li>border:20px solid #6bd5d7;（边框线宽度：20px；边框线类型：solid；边框线颜色：#6bd5d7）</li></ul></li></ul><p><span style="color:#FF6B6B">注：设置width或height时默认是设置的内容展示区域的宽度或高度，添加padding就会使盒子撑大，若不想撑大可以使用 box-sizing:border-box;（默认是content-box）</span></p><h4 id="6-flex布局："><a href="#6-flex布局：" class="headerlink" title="(6) flex布局："></a>(6) flex布局：</h4><ul><li>定义：弹性布局，一维布局模型，可以为元素之间提供强大的空间分布和对齐能力</li><li>使用：通过给父容器添加flex的相关属性，来控制子元素的位置和排列方式</li><li>属性：<ul><li>display:flex ：使用flex布局</li><li>flex-direction:<ul><li>row ：主轴为x轴，水平向右（默认）</li><li>column ：主轴为y轴，垂直向下</li></ul></li><li>justify-content:<ul><li>flex-start ：从头开始排列</li><li>flex-end ：从尾部开始排列</li><li>center ：在主轴居中对齐</li><li>space-around ：平分剩余空间</li><li>space-between ：先两边贴边，再平分剩余空间</li></ul></li></ul></li></ul><h2 id="4-JavaScript：跨平台、面向对象的脚本语言"><a href="#4-JavaScript：跨平台、面向对象的脚本语言" class="headerlink" title="4.JavaScript：跨平台、面向对象的脚本语言"></a>4.JavaScript：跨平台、面向对象的脚本语言</h2><h4 id="1-组成："><a href="#1-组成：" class="headerlink" title="(1) 组成："></a>(1) 组成：</h4><ul><li>ECMAScript：规定了JS基础语法核心知识，如变量、数据类型、函数等</li><li>BOM：浏览器对象模型，用于操作浏览器本身，如页面弹窗、地址栏操作、关闭窗口等</li><li>DOM：文档对象模型，用于操作HTML文档，如改变标签内的内容、改变标签内字体样式等</li></ul><h4 id="2-引入方式："><a href="#2-引入方式：" class="headerlink" title="(2) 引入方式："></a>(2) 引入方式：</h4><ul><li>内部脚本：将JS代码定义在HTML页面中<ul><li>JavaScript代码必须位于&lt; script &gt;&lt; &#x2F;script &gt;标签之间</li><li>在HTML文档中，可以在任意地方，放置任意数量的&lt; script &gt;</li><li>一般会把脚本置于&lt; body &gt;元素里面的底部，可改善显示速度</li></ul></li><li>外部脚本：将JS代码定义在外部JS文件中，然后引入到HTML页面中</li></ul><h4 id="3-书写规范："><a href="#3-书写规范：" class="headerlink" title="(3) 书写规范："></a>(3) 书写规范：</h4><ul><li>结束符：每行结尾以分号结尾，结尾分号可有可无</li></ul><h4 id="4-基础语法"><a href="#4-基础语法" class="headerlink" title="(4)  基础语法:"></a>(4)  基础语法:</h4><ul><li>变量：JS中用let关键字来声明变量（弱类型语言，变量可以存放不同类型的值）<ul><li>变量名规则：</li></ul>  <img src="/2025/01/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/2.jpg" class=""></li></ul><p><span style="color:#FF6B6B">注：在早期的JS中，声明变量还可以使用var，但是并不严谨（不推荐）</span></p><ul><li><p>常量：JS中用const关键字来声明常量</p><ul><li>一旦声明，常量的值就不能改变（不可以重新赋值）</li></ul></li><li><p>输出语句：</p><ul><li>window.alert()：弹出警告框（使用频次较高）</li><li>console.log()：写入浏览器控制台（使用频次较高）</li><li>document.write()：向HTML的body内输出内容</li></ul></li><li><p>数据类型：</p><ul><li><p>基本数据类型：</p><ul><li>number：数字（整数、小数、NaN（Not a Number））</li><li>boolean：布尔（true，false）</li><li>null：对象为空（JavaScript是大小写敏感的，因此null、Null、NULL是完全不同的）</li><li>undefined：当声明的变量未初始化时，该变量的默认值是undefined</li><li>string：字符串（单引号、双引号、反引号(&#96; &#96;)皆可（推荐使用单引号））</li><li>模板字符串：&#96;${}&#96;，用于简化字符串拼接</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;大家好，我是新入职的&#x27;</span> + name + <span class="hljs-string">&#x27;，今年&#x27;</span> + age + <span class="hljs-string">&#x27;岁了，请多多关照&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`大家好，我是新入职的<span class="hljs-subst">$&#123;name&#125;</span>，今年<span class="hljs-subst">$&#123;age&#125;</span>岁了，请多多关照`</span>)<br></code></pre></td></tr></table></figure></li></ul><p>  <span style="color:#FF6B6B">注：使用 typeof 运算符可以获取数据类型</span></p><ul><li>引用数据类型（对象）</li></ul></li><li><p>函数：</p><ul><li><p>介绍：函数是被设计用来执行特定任务的代码块，方便程序的封装复用</p></li><li><p>定义：JavaScript中的函数通过function关键字进行定义</p><ul><li>不需要定义返回值类型和参数类型（弱类型语言）</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2.</span>..</span>)&#123;<br><span class="hljs-comment">//要执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>调用方式:函数名称(参数列表)</li></ul></li></ul></li></ul><p><span style="color:#FF6B6B">注：在调用函数时，实参个数与形参个数可以不一致，但是建议一致</span></p><ul><li><p>匿名函数：</p><ul><li><p>函数表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> add = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>箭头函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>调用：通过变量名直接调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-title function_">alert</span>(result);  <span class="hljs-comment">// 输出 30</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>自定义对象：</p><ul><li>定义格式：</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> 对象名 = &#123;<br>属性名<span class="hljs-number">1</span>:属性值<span class="hljs-number">1</span>,<br>属性名<span class="hljs-number">2</span>:属性值<span class="hljs-number">2</span>,<br>属性名<span class="hljs-number">3</span>:属性值<span class="hljs-number">3</span>,<br>方法名: <span class="hljs-keyword">function</span>(<span class="hljs-params">形参列表</span>)&#123;<br>...            <br>&#125;,<br>方法名(形参列表)&#123;<br>...    <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><span style="color:#FF6B6B">注：在定义对象中的方法时，尽量不要使用箭头函数（箭头函数中this指向有问题，并不指向当前对象，而是其父级对象）</span></p><ul><li>json：<ul><li>概念：JavaScript对象标记法（JS对象标记法书写的文本）</li><li>由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输</li></ul>  <img src="/2025/01/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/3.jpg" class=""></li></ul><h4 id="5-DOM"><a href="#5-DOM" class="headerlink" title="(5)  DOM:"></a>(5)  DOM:</h4><ul><li><p>概念：文档对象模型</p></li><li><p>将标记语言的各个组成部分封装为对应的对象：</p><ul><li>Document：整个文档对象</li><li>Element：元素对象</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul></li><li><p>JavaScript通过DOM就能够对HTML进行操作：</p><ul><li>改变HTML元素内容</li><li>改变HTML元素样式（CSS）</li><li>对HTML DOM事件作出反应</li><li>添加和删除HTML元素</li></ul></li><li><p>DOM操作核心思想：将网页中所有的元素当作对象来处理（标签的所有属性在该对象上都可以找到）</p></li><li><p>操作步骤：</p><ul><li>获取要操作的DOM元素对象<ul><li>根据CSS选择器来获取DOM元素，获取匹配到的第一个元素：document.querySelector(‘选择器’)</li><li>根据CSS选择器来获取DOM元素，获取匹配到的所有元素：document.querySelectorAll(‘选择器’)</li></ul></li></ul><p>  <span style="color:#FF6B6B">注：得到的是一个NodeList节点集合，是一个伪数组（有长度、有索引的数组）</span></p><ul><li>操作DOM对象的属性或方法（查文档或AI）</li></ul></li></ul><h4 id="6-事件监听"><a href="#6-事件监听" class="headerlink" title="(6)  事件监听:"></a>(6)  事件监听:</h4><ul><li>语法：事件源.addEventListener(‘事件类型’,事件触发执行的函数)</li></ul><img src="/2025/01/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/4.jpg" class=""><ul><li>事件监听三要素：<ul><li>事件源：哪个DOM元素触发了事件，要获取DOM元素</li><li>事件类型：用什么方式触发，如鼠标单击</li><li>事件触发执行的函数：要做什么事</li></ul></li><li>常见事件：<ul><li>鼠标事件：<ul><li>click：鼠标点击</li><li>mouseenter：鼠标移入</li><li>mouseleave：鼠标移出</li></ul></li><li>键盘事件：<ul><li>keydown：键盘按下触发</li><li>keyup：键盘抬起触发</li></ul></li><li>焦点事件：<ul><li>focus：获得焦点触发</li><li>blur：失去焦点触发</li></ul></li><li>表单事件：<ul><li>input：用户输入时触发</li><li>submit：表单提交时触发</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库基础</title>
    <link href="/2025/01/12/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/01/12/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一、SQL通用语法"><a href="#一、SQL通用语法" class="headerlink" title="一、SQL通用语法"></a><strong>一、SQL通用语法</strong></h2><p>1.SQL语句可以单行或多行书写，以分号结尾<br>2.SQL语句可以使用空格&#x2F;缩进来增强语句的可读性<br>3.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写<br>4.注释：</p><ul><li>单行注释：–注释内容 或 #注释内容（MySQL特有）</li><li>多行注释：&#x2F;* 注释内容 *&#x2F;</li></ul><h2 id="二、DDL（数据定义语言）"><a href="#二、DDL（数据定义语言）" class="headerlink" title="二、DDL（数据定义语言）"></a><strong>二、DDL（数据定义语言）</strong></h2><h3 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1.数据库操作"></a>1.数据库操作</h3><p>(1).查询</p><ul><li>查询所有数据库：SHOW DATABASES;</li><li>查询当前数据库：SELECT DATABASE();</li></ul><p>(2).创建</p><ul><li>CREATE DATABASE [ IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]；</li></ul><p>(3).删除</p><ul><li>DROP DATABASE [IF EXISTS] 数据库名；</li></ul><p>(4).使用</p><ul><li>USE 数据库名；</li></ul><h3 id="2-表操作"><a href="#2-表操作" class="headerlink" title="2.表操作"></a>2.表操作</h3><p>(1).查询</p><ul><li>查询当前数据库所有表：SHOW TABLES;</li><li>查询表结构：DESC 表名；</li><li>查询指定表的建表语句：SHOW CREATE TABLE 表名；</li></ul><p>(2).创建</p><ul><li>CREATE TABLE 表名（<br>字段1 字段1类型[COMMENT 字段1注释],<br>字段2 字段2类型[COMMENT 字段2注释],<br>字段3 字段3类型[COMMENT 字段3注释],<br>…….<br>字段n 字段n类型[COMMENT 字段n注释]<br>   ）[COMMENT 表注释]；</li></ul><p><span style="color:#FF6B6B">注：最后一个字段后面没有逗号</span></p><p>(3).修改</p><ul><li>添加：ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束]；</li><li>修改：<ul><li>修改数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度)；</li><li>修改字段名和字段类型：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]；</li><li>删除字段：ALTER TABLE 表名 DROP 字段名；</li><li>修改表名：ALTER TABLE 表名 RENAME TO 新表名；</li></ul></li></ul><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h3><p>(1).数值类型：</p><blockquote><p>TINYINT：1 byte<br>  SMALLINT：2 bytes<br>  MEDIUMINT：3 bytes<br>  INT或INTEGER：4 bytes<br>  BIGINT：8 bytes<br>  FLOAT：4 bytes<br>  DOUBLE：8 bytes<br>  DECIMAL：依赖于M（精度）和 D（标度）的值</p></blockquote><p><span style="color:#FF6B6B">注：UNSIGNED表明无符号，即不能为负(例：age tinyint unsigned)</span></p><p>(2).字符串类型：</p><blockquote><p>CHAR：0-255 bytes 定长字符串<br>  VARCHAR：0-65535 bytes 变长字符串<br>  TINYBLOB：0-255 bytes 不超过255个字符的二进制数据<br>  TINYTEXT：0-255 bytes 短文本字符串<br>  BLOB：0-65535 bytes 二进制长文本数据<br>  TEXT：0-65535 bytes 长文本数据<br>  MEDIUMBLOB：0-16777215 bytes 二进制形式的中等长度文本数据<br>  MEDIUMTEXT：0-16777215 bytes 中等长度文本数据<br>  LONGBLOB：0-4294967295 bytes 二进制形式的极大文本数据<br>  LONGTEXT：0-4294967295 bytes 极大文本数据</p></blockquote><p><span style="color:#FF6B6B">注：CHAR和VARCHAR区别：假设声明char(10)和varchar(10)，char即便存储1个字符也会占用10个字符的空间，未占用的空间会用空格填充；varchar存储1个字符就占用1个字符的空间，会根据你存储的内容去计算所需空间。所以char的性能更好，而varchar更省内存</span></p><p>(3).日期类型：</p><blockquote><p>DATE：YYYY-MM-DD 日期值<br>  TIME：HH:MM:SS 时间值或持续时间<br>  YEAR：YYYY 年份值<br>  DATETIME：YYYY-MM-DD HH:MM:SS 混合日期和时间值<br>  TIMESTAMP：YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳</p></blockquote><h2 id="三、DML（数据操作语言）"><a href="#三、DML（数据操作语言）" class="headerlink" title="三、DML（数据操作语言）"></a><strong>三、DML（数据操作语言）</strong></h2><h3 id="1-添加数据"><a href="#1-添加数据" class="headerlink" title="1.添加数据"></a>1.添加数据</h3><p>(1).给指定字段添加数据：INSERT INTO 表名 (字段1,字段2,…) VALUES(值1,值2,…);<br>(2).给全部字段添加数据：INSERT INTO 表名 VALUES(值1,值2,…);<br>(3).批量添加数据：</p><ul><li>INSERT INTO 表名 (字段名1,字段名2,…) VALUES (值1,值2,…),(值1,值2,…),(值1,值2,…);</li><li>INSERT INTO 表名 VALUES (值1,值2,…),(值1,值2,…),(值1,值2,…);</li></ul><p><span style="color:#FF6B6B">注：</span></p><ul><li><span style="color:#FF6B6B">插入数据时，指定的字段顺序需要与值的顺序是一一对应的</span></li><li><span style="color:#FF6B6B">字符串和日期型数据应该包含在引号中</span></li><li><span style="color:#FF6B6B">插入的数据大小应该在字段的规定范围内</span></li></ul><h3 id="2-修改数据"><a href="#2-修改数据" class="headerlink" title="2.修改数据"></a>2.修改数据</h3><p>(1).修改：UPDATE 表名 SET 字段名1&#x3D;值1,字段名2&#x3D;值2,…[WHERE 条件];<br>(2).删除：DELETE FROM 表名 [WHERE 条件];</p><p><span style="color:#FF6B6B">注：</span></p><ul><li><span style="color:#FF6B6B">DELETE 语句的条件可以有，也可以没有，如果没有条件，就会删除这张表所有数据</span></li><li><span style="color:#FF6B6B">DELETE 语句不能删除某一个字段的值(可以使用UPDATE，直接将该字段修改为null)</span></li></ul><h2 id="四、DQL（数据查询语言）"><a href="#四、DQL（数据查询语言）" class="headerlink" title="四、DQL（数据查询语言）"></a><strong>四、DQL（数据查询语言）</strong></h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h3><p>SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数</p><h3 id="2-基本查询"><a href="#2-基本查询" class="headerlink" title="2.基本查询"></a>2.基本查询</h3><p>(1).查询多个字段：</p><ul><li>SELECT 字段1,字段2,字段3… FROM 表名;</li><li>SELECT * FROM 表名;</li></ul><p>(2).设置别名：SELECT 字段1 [AS 别名1],字段2 [AS 别名2]… FROM 表名;<br>(3).去除重复记录：SELECT DISTINCT 字段列表 FROM 表名;</p><h3 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3.条件查询"></a>3.条件查询</h3><p>(1).语法：SELECT 字段列表 FROM 表名 WHERE 条件列表;<br>(2).条件：</p><ul><li><p>比较运算符</p><blockquote><p><code>&gt;</code>：大于<br> <code>&gt;=</code>：大于等于<br> <code>&lt;</code>：小于<br> <code>&lt;=</code>：小于等于<br><code>=</code>：等于<br> <code>&lt;&gt;</code> 或 <code>!=</code>：不等于<br> <code>BETWEEN...AND...</code>：在某个范围之内（含最小、最大值，<code>BETWEEN</code>后跟最小值，<code>AND</code>后跟最大值）<br> <code>IN(...)</code>：在<code>IN</code>之后的列表中的值，多选一<br> <code>LIKE</code>占位符：模糊匹配（<code>_</code>匹配单个字符，<code>%</code>匹配任意个字符）<br><code>IS NULL</code>：是<code>NULL</code></p></blockquote></li><li><p>逻辑运算符</p><blockquote><p>AND 或 &amp;&amp;：并且（多个条件同时成立）<br>OR 或 ||：或者（多个条件任意一个成立）<br>NOT 或 ！：非，不是</p></blockquote></li></ul><h3 id="4-聚合函数"><a href="#4-聚合函数" class="headerlink" title="4.聚合函数"></a>4.聚合函数</h3><p>(1).介绍：将一列数据作为一个整体，进行纵向计算<br>(2).常见聚合函数</p><blockquote><p>count：统计数量<br>  max：最大值<br>  min：最小值<br>  avg：平均值<br>  sum：求和</p></blockquote><p>(3).语法：SELECT 聚合函数(字段列表) FROM 表名;</p><p><span style="color:#FF6B6B">注：null值不参与所有聚合函数运算</span></p><h3 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5.分组查询"></a>5.分组查询</h3><p>(1).语法：SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];<br>(2).WHERE 与 HAVING区别</p><ul><li>执行时机不同：WHERE是分组前进行过滤，不满足WHERE条件，不参与分组；HAVING是分组后对结果进行过滤</li><li>判断条件不同：WHERE不能对聚合函数进行判断，而HAVING可以</li></ul><h3 id="6-排序查询"><a href="#6-排序查询" class="headerlink" title="6.排序查询"></a>6.排序查询</h3><p>(1).语法：SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;<br>(2).排序方式：</p><ul><li>ASC：升序(默认值)</li><li>DESC：降序</li></ul><p><span style="color:#FF6B6B">注：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</span></p><h3 id="7-分页查询"><a href="#7-分页查询" class="headerlink" title="7.分页查询"></a>7.分页查询</h3><p>(1).语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</p><p><span style="color:#FF6B6B">注：</span></p><ul><li><span style="color:#FF6B6B">起始索引从0开始，起始索引 &#x3D; (查询页码-1) * 每页显示记录数</span></li><li><span style="color:#FF6B6B">分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT</span></li><li><span style="color:#FF6B6B">如果查询的是第一页数据，起始索引可以省略 </span></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络基础</title>
    <link href="/2025/01/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/01/10/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="1-常见的HTTP请求头和响应头及其作用"><a href="#1-常见的HTTP请求头和响应头及其作用" class="headerlink" title="1.常见的HTTP请求头和响应头及其作用"></a>1.常见的HTTP请求头和响应头及其作用</h3><ul><li>常见请求头（Request Headers）<ul><li>Host：指定请求的服务器域名和端口</li><li>User-Agent：客户端浏览器或应用标识</li><li>Accept：声明客户端可接收的响应数据类型（如 text&#x2F;html）</li><li>Content-Type：请求体的数据类型（如 application&#x2F;json）</li><li>Cookie：携带服务器设置的Cookie信息</li><li>Authorization：用于身份验证（如 Bearer token）</li></ul></li><li>常见响应头（Response Headers）<ul><li>Content-Type：响应体的数据类型（如 application&#x2F;json）</li><li>Set-Cookie：服务器向客户端设置Cookie</li><li>Cache-Control：控制缓存策略（如 no-cache）</li><li>Location：重定向目标URL（如 302 跳转）</li></ul></li></ul><h3 id="2-Cookie和Session的区别"><a href="#2-Cookie和Session的区别" class="headerlink" title="2.Cookie和Session的区别"></a>2.Cookie和Session的区别</h3><ul><li>Cookie<ul><li>存储在客户端（浏览器）</li><li>可设置过期时间</li><li>大小受限（~4KB）</li><li>可能被篡改（需加密）</li></ul></li><li>Session<ul><li>存储在服务器端</li><li>默认基于会话（浏览器关闭失效）</li><li>存储数据量更大</li><li>更安全</li></ul></li></ul><p>Cookie工作原理：<br>(1) 服务器通过 Set-Cookie 响应头下发Cookie。<br>(2) 浏览器存储Cookie，后续请求自动携带 Cookie 请求头。<br>(3) 服务器读取Cookie进行身份验证或状态管理。</p><h3 id="3-常见HTTP状态码"><a href="#3-常见HTTP状态码" class="headerlink" title="3.常见HTTP状态码"></a>3.常见HTTP状态码</h3><ul><li>200 OK：请求成功</li><li>301 Moved Permanently：永久重定向</li><li>302 Found：临时重定向</li><li>400 Bad Request：请求语法错误</li><li>401 Unauthorized：未认证</li><li>403 Forbidden：无权限访问</li><li>404 Not Found：资源不存在</li><li>500 Internal Server Error：服务器内部错误</li></ul><h3 id="4-Ajax请求及实现"><a href="#4-Ajax请求及实现" class="headerlink" title="4.Ajax请求及实现"></a>4.Ajax请求及实现</h3><p><strong>Ajax（Asynchronous JavaScript and XML） 是一种异步请求技术，无需刷新页面即可获取数据</strong>。</p><p>示例：<br>(1) 原生JavaScript:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://api.example.com/data&quot;</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 异步请求</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>)); <span class="hljs-comment">// 解析响应数据</span><br>  &#125;<br>&#125;;<br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><p>(2) 现代方式(Fetch API)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.example.com/data&quot;</span>)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br></code></pre></td></tr></table></figure><h3 id="5-HTML5新特性"><a href="#5-HTML5新特性" class="headerlink" title="5.HTML5新特性"></a>5.HTML5新特性</h3><ul><li>语义化标签：&lt; header &gt;, &lt; footer &gt;, &lt; article &gt;, &lt; section &gt;</li><li>多媒体支持：&lt; video &gt;, &lt; audio &gt;</li><li>本地存储：localStorage, sessionStorage</li><li>Canvas&#x2F;SVG绘图：动态图形渲染</li><li>Web Workers：多线程计算</li></ul><h3 id="6-JavaScript闭包"><a href="#6-JavaScript闭包" class="headerlink" title="6.JavaScript闭包"></a>6.JavaScript闭包</h3><p><strong>闭包（Closure） 是函数与其词法环境的组合，允许函数访问外部作用域的变量。</strong></p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>        count++;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;;<br>&#125;<br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">outer</span>();<br><span class="hljs-title function_">counter</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">counter</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p><strong>作用： 封装私有变量、实现模块化。</strong></p><h3 id="7-JSON数据格式"><a href="#7-JSON数据格式" class="headerlink" title="7.JSON数据格式"></a>7.JSON数据格式</h3><p><strong>JSON（JavaScript Object Notation） 是轻量级数据交换格式。</strong></p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-keyword">const</span> jsonStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj); <span class="hljs-comment">// 转为JSON字符串</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonStr); <span class="hljs-comment">// &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;</span><br><br><span class="hljs-keyword">const</span> parsedObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonStr); <span class="hljs-comment">// 解析回对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsedObj.<span class="hljs-property">name</span>); <span class="hljs-comment">// Alice</span><br></code></pre></td></tr></table></figure><h3 id="8-正则表达式验证邮箱"><a href="#8-正则表达式验证邮箱" class="headerlink" title="8.正则表达式验证邮箱"></a>8.正则表达式验证邮箱</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> emailRegex = <span class="hljs-regexp">/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,&#125;$/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(emailRegex.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;test@example.com&quot;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="9-Jsoup-CSS选择器-vs-XPath"><a href="#9-Jsoup-CSS选择器-vs-XPath" class="headerlink" title="9.Jsoup CSS选择器 vs XPath"></a>9.Jsoup CSS选择器 vs XPath</h3><p>(1) Jsoup CSS选择器示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Elements</span> <span class="hljs-variable">links</span> <span class="hljs-operator">=</span> doc.select(<span class="hljs-string">&quot;a[href]&quot;</span>); <span class="hljs-comment">// 获取所有带href的&lt;a&gt;标签</span><br></code></pre></td></tr></table></figure><p>(2) XPath示例（需结合其他库如Jsoup+XPath）：</p><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xpath">//a[@href]  # 获取所有带href的<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>标签</span><br></code></pre></td></tr></table></figure><p><strong>区别：</strong></p><ul><li><strong>CSS选择器：更简洁，适合HTML解析。</strong></li><li><strong>XPath：功能更强大，支持复杂路径查询。</strong></li></ul><h3 id="10-WebMagic核心组件"><a href="#10-WebMagic核心组件" class="headerlink" title="10.WebMagic核心组件"></a>10.WebMagic核心组件</h3><ul><li>Downloader：下载网页</li><li>PageProcessor：解析页面（定义爬取逻辑）</li><li>Scheduler：URL调度（去重、队列管理）</li><li>Pipeline：数据存储（如存数据库）</li></ul><h3 id="11-MyBatis-vs-Hibernate"><a href="#11-MyBatis-vs-Hibernate" class="headerlink" title="11.MyBatis vs Hibernate"></a>11.MyBatis vs Hibernate</h3><ul><li>MyBatis<ul><li>SQL手动编写</li><li>更灵活，适合复杂查询</li><li>基于XML&#x2F;注解</li></ul></li><li>Hibernate<ul><li>自动生成SQL</li><li>更自动化，适合简单CRUD</li><li>基于JPA标准</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Ajax</tag>
      
      <tag>HTTP</tag>
      
      <tag>MyBatis</tag>
      
      <tag>Jsoup</tag>
      
      <tag>XPath</tag>
      
      <tag>Hibernate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2024/11/29/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/11/29/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h2><h4 id="1-Java核心优势：跨平台"><a href="#1-Java核心优势：跨平台" class="headerlink" title="1.Java核心优势：跨平台"></a>1.Java核心优势：跨平台</h4><h4 id="2-运行机制："><a href="#2-运行机制：" class="headerlink" title="2.运行机制："></a>2.运行机制：</h4><ul><li>源文件（java文件）-&gt;编译器-&gt;字节码（class文件）-&gt;JVM虚拟机-&gt;操作系统</li></ul><h4 id="3-Java语言即有编译型也有解释型"><a href="#3-Java语言即有编译型也有解释型" class="headerlink" title="3.Java语言即有编译型也有解释型"></a>3.Java语言即有编译型也有解释型</h4><h4 id="4-main方法："><a href="#4-main方法：" class="headerlink" title="4.main方法："></a>4.main方法：</h4><ul><li>Java应用程序的入口方法，格式固定：pulic static void main(String[] args){}</li></ul><h4 id="5-每个类都会生成一个class文件"><a href="#5-每个类都会生成一个class文件" class="headerlink" title="5.每个类都会生成一个class文件"></a>5.每个类都会生成一个class文件</h4><h4 id="6-JDK和JRE和JVM："><a href="#6-JDK和JRE和JVM：" class="headerlink" title="6.JDK和JRE和JVM："></a>6.JDK和JRE和JVM：</h4><img src="/2024/11/29/Java%E5%9F%BA%E7%A1%80/1.jpg" class=""><h4 id="7-DOS命令："><a href="#7-DOS命令：" class="headerlink" title="7.DOS命令："></a>7.DOS命令：</h4><ul><li>cd 目录路径：进入目录</li><li>cd..：进入父目录</li><li>dir：查看本目录下的文件和子目录列表</li><li>cls：清除屏幕命令</li></ul><h4 id="8-十进制转二进制：除2取余，逆序排列"><a href="#8-十进制转二进制：除2取余，逆序排列" class="headerlink" title="8.十进制转二进制：除2取余，逆序排列"></a>8.十进制转二进制：除2取余，逆序排列</h4><h4 id="9-注释："><a href="#9-注释：" class="headerlink" title="9.注释："></a>9.注释：</h4><ul><li>单行注释：&#x2F;&#x2F;</li><li>多行注释：&#x2F;*   *&#x2F;</li><li>文档注释：&#x2F;**  *&#x2F;</li></ul><h4 id="10-Java不采用ASCII字符集，采用Unicode字符集"><a href="#10-Java不采用ASCII字符集，采用Unicode字符集" class="headerlink" title="10.Java不采用ASCII字符集，采用Unicode字符集"></a>10.Java不采用ASCII字符集，采用Unicode字符集</h4><h4 id="11-Java方法中所有参数都是“值传递”"><a href="#11-Java方法中所有参数都是“值传递”" class="headerlink" title="11.Java方法中所有参数都是“值传递”"></a>11.Java方法中所有参数都是“值传递”</h4><h2 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h2><h4 id="1-变量：局部变量、成员变量、静态变量"><a href="#1-变量：局部变量、成员变量、静态变量" class="headerlink" title="1.变量：局部变量、成员变量、静态变量"></a>1.变量：局部变量、成员变量、静态变量</h4><p><span style="color:#FF6B6B">注：成员变量属于对象，静态变量属于类</span></p><h4 id="2-数据类型："><a href="#2-数据类型：" class="headerlink" title="2.数据类型："></a>2.数据类型：</h4><ul><li>数值型：<ul><li>整型：byte（1字节）、short（2字节）、int（4字节）、long（8字节）</li><li>浮点型：float（4字节）、double（8字节）</li></ul></li><li>字符型：char</li><li>布尔型：boolean（未赋值则初始化为false）</li></ul><p><span style="color:#FF6B6B">注：字节：byte，1byte&#x3D;8bit</span></p><h4 id="3-二进制以0-零-b开头"><a href="#3-二进制以0-零-b开头" class="headerlink" title="3.二进制以0(零)b开头"></a>3.二进制以0(零)b开头</h4><h4 id="4-默认类型："><a href="#4-默认类型：" class="headerlink" title="4.默认类型："></a>4.默认类型：</h4><ul><li>整型变量默认类型是int，在数字后加L可以把整型常量定义为long类型</li><li>浮点常量默认类型是double，在数字后加F可以把整型常量定义为float类型</li></ul><h4 id="5-取余：余数符号与左边操作数相同"><a href="#5-取余：余数符号与左边操作数相同" class="headerlink" title="5.取余：余数符号与左边操作数相同"></a>5.取余：余数符号与左边操作数相同</h4><ul><li>例：-7%3&#x3D;-1，7%-3&#x3D;1</li></ul><h4 id="6-逻辑运算符："><a href="#6-逻辑运算符：" class="headerlink" title="6.逻辑运算符："></a>6.逻辑运算符：</h4><ul><li>＆（与）：一个为false，结果则为false</li><li>｜（或）：一个为true，结果则为true</li><li>！（非）：取反（true为false，false为true）</li><li>^（异或）：相同为false，不同为true</li><li>＆＆（短路与）：前面为false，后面则不计算</li><li>｜｜（短路或）：前面为true，后面则不计算</li></ul><h4 id="7-”-”（字符串连接符）："><a href="#7-”-”（字符串连接符）：" class="headerlink" title="7.”+”（字符串连接符）："></a>7.”+”（字符串连接符）：</h4><ul><li>条件必须是String，不能是char（若是char仍是加法）</li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> c1=<span class="hljs-string">&#x27;h&#x27;</span>;<br>      <span class="hljs-type">char</span> c2=<span class="hljs-string">&#x27;i&#x27;</span>;<br>      System.out.println(c1+c2);<span class="hljs-comment">//输出为数字</span><br>      System.out.println(<span class="hljs-string">&quot;&quot;</span>+c1+c2);<span class="hljs-comment">//输出为hi)</span><br></code></pre></td></tr></table></figure><h4 id="8-优先级：＆比｜高，＆＆比｜｜高"><a href="#8-优先级：＆比｜高，＆＆比｜｜高" class="headerlink" title="8.优先级：＆比｜高，＆＆比｜｜高"></a>8.优先级：＆比｜高，＆＆比｜｜高</h4><h4 id="9-自动类型转换（隐式类型转换）："><a href="#9-自动类型转换（隐式类型转换）：" class="headerlink" title="9.自动类型转换（隐式类型转换）："></a>9.自动类型转换（隐式类型转换）：</h4><p><strong>自动类型转换规则：</strong></p><p>(1)数值型（整型 → 整型 &#x2F; 整型 → 浮点型）</p><ul><li>byte → short → int → long → float → double</li><li>char（2字节）可以自动转 int（4字节）或更高</li></ul><p>(2)char的特殊情况</p><ul><li>char可以自动转 int（因为 char 是无符号 16 位，int 是 32 位）</li><li>但byte&#x2F;short 不能自动转 char（可能超出范围）</li></ul><p><strong>计算时的自动类型转换：</strong></p><p>(1) 整型运算（至少提升到int）</p><ul><li>byte、short、char 在计算时会先转int</li><li>如果有long&#x2F;float&#x2F;double，则向更大的类型转换</li></ul><p>(2) 混合运算（整型 + 浮点型 → 浮点型）</p><h4 id="10-强制转换-Type"><a href="#10-强制转换-Type" class="headerlink" title="10.强制转换(Type)"></a>10.强制转换(Type)</h4><ul><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-type">int</span>)a; <span class="hljs-comment">//把a强制转换为int类型</span><br></code></pre></td></tr></table></figure><h4 id="11-数据溢出："><a href="#11-数据溢出：" class="headerlink" title="11.数据溢出："></a>11.数据溢出：</h4><p><strong>定义：</strong> 指的是当变量的值 超出其数据类型的存储范围时，导致数据丢失或异常结果的情况。数据溢出通常发生在 整型（int、long、byte、short）运算中，但浮点型（float、double）也可能出现精度问题。</p><p><strong>整型数据溢出:</strong></p><p>(1) 什么是整型溢出？</p><ul><li>当计算结果超出数据类型的最大值或最小值 时，数值会 “回绕”（wrap around）：</li><li>超过最大值→变成最小值</li><li>低于最小值→变成最大值</li></ul><p>(2) 常见溢出场景</p><img src="/2024/11/29/Java%E5%9F%BA%E7%A1%80/2.jpg" class=""><p><strong>浮点型的精度问题:</strong></p><p>(1)虽然float和double不会像整型那样 “回绕”，但浮点数运算可能存在精度丢失：</p><ul><li>float（32位）：有效位数约 6~7 位</li><li>double（64位）：有效位数约 15~16 位</li></ul><p><strong>如何避免数据溢出？</strong><br>(1) 使用更大的数据类型<br>(2) 检查运算是否溢出:Java 8+ 提供了 Math.addExact(), Math.multiplyExact() 等方法，溢出时会抛出 ArithmeticException<br>(3) 使用BigInteger（超大整数）或 BigDecimal（高精度小数）</p><h2 id="三、控制语句"><a href="#三、控制语句" class="headerlink" title="三、控制语句"></a>三、控制语句</h2><h4 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1.条件语句"></a>1.条件语句</h4><p>(1) if-else 语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 条件1为 true 时执行</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件<span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// 条件2为 true 时执行</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 所有条件都不满足时执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(2) switch-case 语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (变量) &#123;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>        <span class="hljs-comment">// 匹配值1时执行</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>        <span class="hljs-comment">// 匹配值2时执行</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// 所有 case 都不匹配时执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p><span style="color:#FF6B6B">注：</span></p><ul><li><span style="color:#FF6B6B">switch支持int、char、String(Java 7+)、enum(枚举)</span></li><li><span style="color:#FF6B6B">不加break会”穿透”（fall-through） 执行后续 case</span></li></ul><h4 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2. 循环语句"></a>2. 循环语句</h4><p>(1) for 循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (初始化; 条件; 更新) &#123;<br>    <span class="hljs-comment">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(2) while 循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (条件) &#123;<br>    <span class="hljs-comment">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(3) do-while 循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// 循环体（至少执行一次）</span><br>&#125; <span class="hljs-keyword">while</span> (条件);<br></code></pre></td></tr></table></figure><p>(4) 增强 for 循环（for-each）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (数据类型 变量 : 数组/集合) &#123;<br>    <span class="hljs-comment">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-跳转语句"><a href="#3-跳转语句" class="headerlink" title="3. 跳转语句"></a>3. 跳转语句</h4><p>(1) break</p><ul><li>立即终止当前循环或 switch 语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 当 i=5 时跳出循环</span><br>    &#125;<br>    System.out.println(i);  <span class="hljs-comment">// 输出 0,1,2,3,4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(2) continue</p><ul><li>跳过本次循环，进入下一次循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 跳过 i=2 的情况</span><br>    &#125;<br>    System.out.println(i);  <span class="hljs-comment">// 输出 0,1,3,4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(3) return</p><ul><li>退出当前方法，并返回一个值（如果有返回值）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;  <span class="hljs-comment">// 返回 a + b 的结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(4) 带标签的 break 和 continue</p><ul><li>可以跳出多层循环（适用于嵌套循环）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">outerLoop:  <span class="hljs-comment">// 标签</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">break</span> outerLoop;  <span class="hljs-comment">// 直接跳出外层循环</span><br>        &#125;<br>        System.out.println(i + <span class="hljs-string">&quot;,&quot;</span> + j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、构造器"><a href="#四、构造器" class="headerlink" title="四、构造器"></a>四、构造器</h2><h4 id="1-构造器通过new关键字调用"><a href="#1-构造器通过new关键字调用" class="headerlink" title="1.构造器通过new关键字调用"></a>1.构造器通过new关键字调用</h4><h4 id="2-返回值："><a href="#2-返回值：" class="headerlink" title="2.返回值："></a>2.返回值：</h4><ul><li>构造器虽然有返回值，但不能定义返回值类型（返回值的类型肯定是本类）</li><li>不能在构造器里使用return返回值</li></ul><h4 id="3-没有定义构造器："><a href="#3-没有定义构造器：" class="headerlink" title="3.没有定义构造器："></a>3.没有定义构造器：</h4><ul><li>若没有定义构造器，编译器会自动定义一个无参构造方法，若定义了则不会添加</li></ul><h4 id="4-构造器方法名必须和类名一致"><a href="#4-构造器方法名必须和类名一致" class="headerlink" title="4.构造器方法名必须和类名一致"></a>4.构造器方法名必须和类名一致</h4><h4 id="5-构造器调用构造器"><a href="#5-构造器调用构造器" class="headerlink" title="5.构造器调用构造器:"></a>5.构造器调用构造器:</h4><ul><li>可以用this()，但必须位于第一行<ul><li>this（隐式参数）代表当前对象本身（对象地址）</li><li>this不能在static方法中使用（因为static属于类）</li></ul></li></ul><h2 id="五、常用修饰符"><a href="#五、常用修饰符" class="headerlink" title="五、常用修饰符"></a>五、常用修饰符</h2><h4 id="1-static-修饰符"><a href="#1-static-修饰符" class="headerlink" title="1. static 修饰符"></a>1. static 修饰符</h4><p>(1) 作用：表示类级别的成员（与对象无关），所有对象共享同一份数据。<br>(2) 应用场景：</p><ul><li>修饰变量：静态变量（类变量），如 static int count &#x3D; 0;</li><li>修饰方法：静态方法（类方法），如 static void print() { … }</li><li>修饰代码块：静态代码块（类加载时执行），如 static { … }</li><li>修饰嵌套类：静态内部类，如 static class Inner { … }</li></ul><p>(3) 特点：</p><ul><li>静态方法不能访问非静态成员（因为不依赖对象）。</li><li>静态代码块在类加载时执行一次（用于初始化静态变量）。</li><li>静态变量存储在方法区，所有对象共享。</li></ul><h4 id="2-final-修饰符"><a href="#2-final-修饰符" class="headerlink" title="2. final 修饰符"></a>2. final 修饰符</h4><p>(1) 作用：表示不可变，用于限制变量、方法或类的修改。<br>(2) 应用场景：</p><ul><li>修饰变量：常量（值不可变），如 final int MAX &#x3D; 100;</li><li>修饰方法：禁止子类重写，如 final void show() { … }</li><li>修饰类：禁止继承，如 final class MathUtils { … }</li></ul><p>(3) 特点：</p><ul><li>final变量：<ul><li>基本类型：值不可变。</li><li>引用类型：引用不可变（但对象内部状态可修改）。</li></ul></li><li>final方法：子类不能重写（但可以重载）。</li><li>final类：不能被继承（如 String、Integer）。</li></ul><h4 id="3-abstract-修饰符"><a href="#3-abstract-修饰符" class="headerlink" title="3. abstract 修饰符"></a>3. abstract 修饰符</h4><ul><li>修饰类：不能实例化，需子类继承。</li><li>修饰方法：只有声明，无实现（需子类重写）。</li></ul><h4 id="4-synchronized-修饰符"><a href="#4-synchronized-修饰符" class="headerlink" title="4. synchronized 修饰符"></a>4. synchronized 修饰符</h4><ul><li>用于方法或代码块，保证线程安全。</li></ul><h4 id="5-volatile-修饰符"><a href="#5-volatile-修饰符" class="headerlink" title="5. volatile 修饰符"></a>5. volatile 修饰符</h4><ul><li>保证变量的可见性（多线程场景）。</li></ul><h4 id="6-native-修饰符"><a href="#6-native-修饰符" class="headerlink" title="6. native 修饰符"></a>6. native 修饰符</h4><ul><li>表示方法由本地代码（如 C&#x2F;C++）实现。</li></ul><h2 id="六、面向对象"><a href="#六、面向对象" class="headerlink" title="六、面向对象"></a>六、面向对象</h2><h4 id="1-面向过程与面向对象："><a href="#1-面向过程与面向对象：" class="headerlink" title="1.面向过程与面向对象："></a>1.面向过程与面向对象：</h4><ul><li>面向过程是“执行者思维”</li><li>面向对象是“设计者思维”</li><li>面向对象离不开面向过程：<ul><li>宏观上，通过面向对象进行整体设计</li><li>微观上，执行和处理数据仍然是面向过程</li></ul></li></ul><h4 id="2-类和对象（Class-Object）"><a href="#2-类和对象（Class-Object）" class="headerlink" title="2. 类和对象（Class &amp; Object）"></a>2. 类和对象（Class &amp; Object）</h4><p>(1) 类（Class）</p><ul><li>类是对象的模板，定义对象的属性（成员变量）和行为（方法）。</li><li>语法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 类名 &#123;<br>    <span class="hljs-comment">// 成员变量（属性）</span><br>    数据类型 变量名;<br><br>    <span class="hljs-comment">// 方法（行为）</span><br>    返回类型 方法名(参数列表) &#123;<br>        <span class="hljs-comment">// 方法体</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) 对象（Object）</p><ul><li>对象是类的实例，通过new关键字创建。</li><li>语法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类名 对象名 = <span class="hljs-keyword">new</span> 类名();<br></code></pre></td></tr></table></figure><h4 id="3-封装"><a href="#3-封装" class="headerlink" title="3. 封装"></a>3. 封装</h4><p><strong>定义：</strong> 指隐藏对象的内部细节，仅对外提供访问接口（getter&#x2F;setter）。</p><p>(1) 访问修饰符</p><ul><li>private：仅当前类可访问</li><li>protected：当前类+子类+同包类可访问</li><li>public：所有类可访问</li><li>default(缺省)：当前类+同包类可访问</li></ul><p>(2) Getter&#x2F;Setter</p><ul><li>示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;  <span class="hljs-comment">// 私有属性</span><br><br>    <span class="hljs-comment">// Getter</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-comment">// Setter</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;  <span class="hljs-comment">// this 指当前对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p.setName(<span class="hljs-string">&quot;Bob&quot;</span>);  <span class="hljs-comment">// 通过 setter 修改 name</span><br>System.out.println(p.getName());  <span class="hljs-comment">// 通过 getter 获取 name</span><br></code></pre></td></tr></table></figure><h4 id="4-继承"><a href="#4-继承" class="headerlink" title="4.继承"></a>4.继承</h4><p><strong>定义：</strong> 允许子类复用父类的属性和方法，并可以扩展新功能。</p><p>(1) 语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">class 子类 extends 父类 &#123;<br>    <span class="hljs-comment">// 新增属性或方法</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal is eating&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog is barking&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>dog.eat();  <span class="hljs-comment">// 继承自 Animal</span><br>dog.bark(); <span class="hljs-comment">// Dog 新增方法</span><br></code></pre></td></tr></table></figure><p>(2) 方法重写（Override）</p><ul><li>子类可以重写父类的方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span>  <span class="hljs-comment">// 注解，表示重写（可选）</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog is eating&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(3) super 关键字</p><ul><li>用于调用父类的构造方法或成员方法（访问父类被子类覆盖的方法或属性）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    Dog() &#123;<br>        <span class="hljs-built_in">super</span>();  <span class="hljs-comment">// 调用父类构造方法</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.eat();  <span class="hljs-comment">// 先调用父类的 eat()</span><br>        System.out.println(<span class="hljs-string">&quot;Dog is eating&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><span style="color:#FF6B6B">注：</span></p><ul><li><span style="color:#FF6B6B">一个类若构造方法第一行没调用super(…)或this(…)，那么Java默认调用super()，即调用父类的无参构造方法</span></li><li><span style="color:#FF6B6B">构造方法调用顺序：先向上追溯到Object类，然后再依次向下执行类的初始化块和构造方法，直到子类为止</span></li><li><span style="color:#FF6B6B">属性&#x2F;方法查找：查找当前类→依次向上追溯每个父类，直到Object类→没找到则报错</span></li></ul><h4 id="5-多态"><a href="#5-多态" class="headerlink" title="5. 多态"></a>5. 多态</h4><p><strong>定义：</strong> 指同一个方法在不同情况下有不同的行为。</p><p>(1) 方法重载</p><ul><li>同一个类中，方法名相同，参数不同：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><span style="color:#FF6B6B">注：</span></p><ul><li><span style="color:#FF6B6B">重载是形参不同（形参类型，形参个数，形参顺序），名称相同，实际上是完全不同的方法</span></li><li><span style="color:#FF6B6B">只有返回值类型不同不构成重载（编译器会报错）</span></li><li><span style="color:#FF6B6B">形参只是名称不同也不构成重载</span></li></ul><p>(2) 向上转型</p><ul><li>父类引用指向子类对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();  <span class="hljs-comment">// Dog 是 Animal 的子类</span><br>animal.eat();  <span class="hljs-comment">// 调用的是 Dog 的 eat()</span><br></code></pre></td></tr></table></figure><p>(3) instanceof 判断类型</p><ul><li>判断左边的对象是否属于右边的类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> Dog) &#123;<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> (Dog) animal;  <span class="hljs-comment">// 向下转型</span><br>    dog.bark();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6. 抽象类"></a>6. 抽象类</h4><ul><li>用abstract声明，不能直接实例化，只能被继承。</li><li>可以包含抽象方法（无方法体）和普通方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a shape&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing a circle&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-接口"><a href="#7-接口" class="headerlink" title="7. 接口"></a>7. 接口</h4><ul><li>用interface声明，所有方法默认public abstract。</li><li>Java 8+ 支持默认方法（default）和静态方法（static）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">land</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 默认方法</span><br>        System.out.println(<span class="hljs-string">&quot;Landing...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bird is flying&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
