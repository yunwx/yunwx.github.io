<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>技术问题</title>
    <link href="/2025/02/23/%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2025/02/23/%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-详细解释JVM内存模型（堆、栈、方法区等），并说明垃圾回收机制在高并发场景下的优化思路。"><a href="#1-详细解释JVM内存模型（堆、栈、方法区等），并说明垃圾回收机制在高并发场景下的优化思路。" class="headerlink" title="1.详细解释JVM内存模型（堆、栈、方法区等），并说明垃圾回收机制在高并发场景下的优化思路。"></a>1.详细解释JVM内存模型（堆、栈、方法区等），并说明垃圾回收机制在高并发场景下的优化思路。</h3><ul><li>JVM内存模型：<ul><li>堆（Heap）：存放对象实例，是所有线程共享的，分为新生代（Eden、Survivor区）和老年代。</li><li>栈（Stack）：线程私有，存放局部变量、方法调用栈帧。</li><li>方法区（Metaspace&#x2F;JDK8+）：存储类信息、常量池、静态变量等。</li><li>程序计数器（PC Register）：记录当前线程执行到的字节码行号。</li><li>本地方法栈（Native Method Stack）：执行Native方法（如JNI调用）。</li></ul></li><li>高并发下的GC优化：<ul><li>选择合适的垃圾回收器：如G1或ZGC，减少STW（Stop-The-World）时间。</li><li>调整堆大小：避免频繁Full GC，如-Xms和-Xmx设为相同值，减少动态扩展的开销。</li><li>优化对象分配：减少大对象直接进入老年代，合理设置-XX:MaxTenuringThreshold。</li><li>避免内存泄漏：如使用WeakHashMap管理缓存，防止长生命周期对象持有短生命周期对象的引用。</li></ul></li></ul><h3 id="2-举例说明什么情况下会触发OutOfMemoryError，如何通过工具（如MAT）分析内存泄漏？"><a href="#2-举例说明什么情况下会触发OutOfMemoryError，如何通过工具（如MAT）分析内存泄漏？" class="headerlink" title="2.举例说明什么情况下会触发OutOfMemoryError，如何通过工具（如MAT）分析内存泄漏？"></a>2.举例说明什么情况下会触发OutOfMemoryError，如何通过工具（如MAT）分析内存泄漏？</h3><ul><li>OOM触发场景：<ul><li>堆内存不足：java.lang.OutOfMemoryError: Java heap space（对象过多或内存泄漏）。</li><li>方法区溢出：java.lang.OutOfMemoryError: Metaspace（动态加载大量类）。</li><li>栈溢出：java.lang.StackOverflowError（递归调用过深）。</li></ul></li><li>MAT（Memory Analyzer Tool）分析步骤：<br>  a.使用jmap -dump:format&#x3D;b,file&#x3D;heap.hprof &lt; pid &gt;导出堆内存快照。<br>  b.用MAT打开.hprof文件，分析Dominator Tree，查看占用内存最多的对象。<br>  c.检查Leak Suspects报告，定位可能的泄漏点（如未关闭的连接、静态集合类）。</li></ul><h3 id="3-使用过vue哪些功能？"><a href="#3-使用过vue哪些功能？" class="headerlink" title="3.使用过vue哪些功能？"></a>3.使用过vue哪些功能？</h3><p>(1)组件化开发：通过 Vue 的组件系统，将审核模块（如印章审核、工单审核）拆分为可复用的组件，提升代码维护性。<br>(2)数据绑定与响应式系统：利用 v-model 实现表单输入的双向绑定，并结合 Vue 的响应式特性实时更新界面状态。<br>(3)指令应用：</p><ul><li>v-for：渲染待审核的工单或印章列表</li><li>v-if &#x2F; v-show：根据权限或审核状态动态显示界面元素</li></ul><p>(4)ElementUI 组件库：集成 ElementUI 的表格（el-table）、表单（el-form）、弹窗（el-dialog）等组件，快速构建用户界面。<br>(5)前端路由：通过 Vue Router 实现页面跳转（如从列表页跳转至详情页）。<br>(6)API 通信：使用 axios 或 fetch 调用后端 Spring Boot 接口，完成审核数据的提交与查询。<br>(7)事件处理：通过 @click 等事件监听用户操作（如审核通过、拒绝按钮点击）。<br>(8)状态管理：可能结合 Vuex 管理全局状态（如用户权限、审核流程状态）。</p><h3 id="4-MyBatis-和-MyBatis-Plus-的主要区别"><a href="#4-MyBatis-和-MyBatis-Plus-的主要区别" class="headerlink" title="4.MyBatis 和 MyBatis-Plus 的主要区别?"></a>4.MyBatis 和 MyBatis-Plus 的主要区别?</h3><p>(1)定位与功能</p><ul><li>MyBatis<ul><li>核心功能：一个轻量级的 Java 持久层框架，专注于 SQL 与 Java 对象的映射（ORM），开发者需手动编写 SQL 和 DAO 层代码。</li><li>特点：灵活性强，适合需要精细化控制 SQL 的场景，但对基础 CRUD 操作需要重复编码。</li></ul></li><li>MyBatis-Plus<ul><li>核心功能：基于 MyBatis 的增强工具，在保留 MyBatis 所有特性的基础上，提供了大量开箱即用的功能，大幅简化开发。</li><li>特点：内置通用 Mapper、代码生成器、分页插件、条件构造器等，显著减少重复代码。</li></ul></li></ul><p>(2)核心特性对比</p><img src="/2025/02/23/%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/MyBatis.jpg" class=""><p>(3)开发效率</p><ul><li>MyBatis：适合对 SQL 有高度定制化需求的场景，但需要开发者自行处理大量模板代码（如 CRUD 操作）。</li><li>MyBatis-Plus：通过自动化工具和增强功能，减少 80% 的基础代码量，尤其适合快速开发标准化业务。</li></ul><p>(4)实际应用场景</p><ul><li>选择 MyBatis：<ul><li>需要完全控制 SQL 逻辑（如复杂查询、存储过程调用）。</li><li>项目对第三方依赖敏感，希望保持轻量化。</li></ul></li><li>选择 MyBatis-Plus：<ul><li>需要快速实现基础 CRUD 功能（如后台管理系统）。</li><li>希望减少重复代码，提升开发效率。</li></ul></li></ul><h3 id="5-能否举例说明synchronized和ReentrantLock的区别？"><a href="#5-能否举例说明synchronized和ReentrantLock的区别？" class="headerlink" title="5.能否举例说明synchronized和ReentrantLock的区别？"></a>5.能否举例说明synchronized和ReentrantLock的区别？</h3><ul><li>实现机制：synchronized是JVM层面的关键字，依赖内置锁（Monitor），而ReentrantLock是API层面的锁，基于AQS（AbstractQueuedSynchronizer）。</li><li>功能扩展：ReentrantLock支持公平锁、可中断锁、超时锁等特性，synchronized仅支持非公平锁。</li><li>示例场景：在需要尝试获取锁或避免死锁时，使用ReentrantLock更灵活。例如，在分布式任务调度中，结合tryLock()实现超时等待。</li></ul><h3 id="6-如何判断一个SQL是否需要添加索引？"><a href="#6-如何判断一个SQL是否需要添加索引？" class="headerlink" title="6.如何判断一个SQL是否需要添加索引？"></a>6.如何判断一个SQL是否需要添加索引？</h3><ul><li>慢查询分析：通过EXPLAIN分析执行计划，观察type字段是否为ALL（全表扫描），或rows值是否过大。</li><li>高频查询字段：对WHERE、JOIN、ORDER BY子句中的高频字段添加索引。</li><li>覆盖索引：若查询仅需索引字段，可避免回表。</li></ul><h3 id="7-如何解决缓存穿透问题？"><a href="#7-如何解决缓存穿透问题？" class="headerlink" title="7.如何解决缓存穿透问题？"></a>7.如何解决缓存穿透问题？</h3><ul><li>空值缓存：对查询结果为空的Key也进行缓存（设置较短过期时间），避免频繁查询数据库。</li><li>布隆过滤器：在查询前通过布隆过滤器判断Key是否存在，拦截无效请求。</li></ul><h3 id="8-什么是缓存穿透、击穿、雪崩以及解决方案。"><a href="#8-什么是缓存穿透、击穿、雪崩以及解决方案。" class="headerlink" title="8.什么是缓存穿透、击穿、雪崩以及解决方案。"></a>8.什么是缓存穿透、击穿、雪崩以及解决方案。</h3><p>(1) 缓存穿透（Cache Penetration）</p><ul><li>定义：查询一个数据库中不存在的数据，导致请求直接打到数据库，缓存失去作用。</li><li>原因：恶意请求或非法查询。</li><li>解决方案：<ul><li>布隆过滤器（Bloom Filter）：在缓存层前加布隆过滤器，过滤掉不存在的数据。</li><li>缓存空值：即使查询结果为空，也将空结果缓存，设置较短的过期时间。</li></ul></li></ul><p>(2) 缓存击穿（Cache Breakdown）</p><ul><li>定义：某个热点数据在缓存中过期，同时有大量请求访问该数据，导致请求直接打到数据库。</li><li>原因：热点数据集中过期。</li><li>解决方案：<ul><li>设置热点数据永不过期：对热点数据不设置过期时间，或通过异步任务定期更新。</li><li>互斥锁（Mutex Lock）：当缓存失效时，只允许一个线程去查询数据库并更新缓存，其他线程等待。</li></ul></li></ul><p>(3) 缓存雪崩（Cache Avalanche）</p><ul><li>定义：大量缓存数据在同一时间过期，导致大量请求直接打到数据库，造成数据库压力激增。</li><li>原因：缓存集中过期或缓存服务宕机。</li><li>解决方案：<ul><li>分散过期时间：为缓存数据设置随机的过期时间，避免集中过期。</li><li>多级缓存：使用多级缓存（如本地缓存 + Redis），减少对单一缓存的依赖。</li><li>高可用架构：通过 Redis 集群或哨兵模式保证缓存服务的高可用性。</li></ul></li></ul><h3 id="9-Redis-数据类型"><a href="#9-Redis-数据类型" class="headerlink" title="9.Redis 数据类型"></a>9.Redis 数据类型</h3><p>(1) String（字符串）：</p><ul><li>最基本的数据类型，可以存储文本、数字或二进制数据。</li><li>常用命令：SET, GET, INCR, DECR。</li></ul><p>(2) Hash（哈希）：</p><ul><li>类似于字典，存储键值对集合，适合存储对象。</li><li>常用命令：HSET, HGET, HGETALL, HDEL。</li></ul><p>(3) List（列表）：</p><ul><li>有序的字符串列表，支持从两端插入或删除元素。</li><li>常用命令：LPUSH, RPUSH, LPOP, RPOP, LRANGE。</li></ul><p>(4) Set（集合）：</p><ul><li>无序且唯一的字符串集合，支持交集、并集等操作。</li><li>常用命令：SADD, SMEMBERS, SINTER, SUNION。</li></ul><p>(5) Sorted Set（有序集合）：</p><ul><li>类似于 Set，但每个元素关联一个分数，用于排序。</li><li>常用命令：ZADD, ZRANGE, ZSCORE, ZREM。</li></ul><p>(6) Bitmaps（位图）：</p><ul><li>通过位操作存储布尔值，适合存储标志位或进行位运算。</li><li>常用命令：SETBIT, GETBIT, BITCOUNT。</li></ul><p>(7) HyperLogLog：</p><ul><li>用于基数统计，适合估算集合中唯一元素的数量。</li><li>常用命令：PFADD, PFCOUNT, PFMERGE。</li></ul><p>(8) Geospatial（地理空间）：</p><ul><li>存储地理位置信息，支持计算距离、范围查询等操作。</li><li>常用命令：GEOADD, GEODIST, GEORADIUS。</li></ul><h3 id="10-熟悉哪些设计模式？请举例说明在项目中如何使用设计模式。"><a href="#10-熟悉哪些设计模式？请举例说明在项目中如何使用设计模式。" class="headerlink" title="10. 熟悉哪些设计模式？请举例说明在项目中如何使用设计模式。"></a>10. 熟悉哪些设计模式？请举例说明在项目中如何使用设计模式。</h3><ul><li>我熟悉常用的设计模式，如单例模式、工厂模式、观察者模式等。</li><li>在一个项目中，我使用了单例模式来确保数据库连接池的唯一性，避免重复创建连接。此外，我还使用了工厂模式来创建不同类型的支付对象（如支付宝、微信支付），通过工厂类来统一管理支付对象的创建。</li></ul><h3 id="11-你如何使用Git进行版本控制？请描述你在团队协作中的Git工作流程。"><a href="#11-你如何使用Git进行版本控制？请描述你在团队协作中的Git工作流程。" class="headerlink" title="11. 你如何使用Git进行版本控制？请描述你在团队协作中的Git工作流程。"></a>11. 你如何使用Git进行版本控制？请描述你在团队协作中的Git工作流程。</h3><ul><li>我通常使用Git进行代码版本管理，常用的命令包括git clone、git pull、git commit、git push等。</li><li>在团队协作中，我们采用Git Flow工作流。每个新功能或修复都会从develop分支创建一个新的特性分支，开发完成后通过Pull Request合并回develop分支。发布时，我们会从develop分支创建release分支，经过测试后再合并到master分支。</li></ul><h3 id="12-你如何优化MySQL查询性能？请举例说明你在项目中如何进行数据库优化。"><a href="#12-你如何优化MySQL查询性能？请举例说明你在项目中如何进行数据库优化。" class="headerlink" title="12. 你如何优化MySQL查询性能？请举例说明你在项目中如何进行数据库优化。"></a>12. 你如何优化MySQL查询性能？请举例说明你在项目中如何进行数据库优化。</h3><ul><li>我通常通过以下几种方式优化MySQL查询性能：<br>i.使用索引：为常用的查询字段创建索引，避免全表扫描。<br>ii.优化SQL语句：避免使用SELECT *，只查询需要的字段；避免使用子查询和不必要的JOIN。<br>iii.分库分表：对于大数据量的表，采用分库分表策略。</li><li>在一个电商项目中，我通过为订单表的user_id和order_date字段创建复合索引，显著提升了查询性能。</li></ul><h3 id="13-你如何使用Redis？请举例说明你在项目中如何使用Redis解决实际问题。"><a href="#13-你如何使用Redis？请举例说明你在项目中如何使用Redis解决实际问题。" class="headerlink" title="13. 你如何使用Redis？请举例说明你在项目中如何使用Redis解决实际问题。"></a>13. 你如何使用Redis？请举例说明你在项目中如何使用Redis解决实际问题。</h3><ul><li>Redis是一个高性能的键值存储系统，常用于缓存、会话管理和消息队列等场景。</li><li>在一个高并发的电商项目中，我使用Redis缓存商品详情信息，减少数据库的查询压力。当用户请求商品详情时，首先从Redis中获取数据，如果缓存中没有，再从数据库中查询并写入Redis。</li></ul><h3 id="14-你熟悉Spring-Cloud吗？请举例说明你在微服务架构中如何使用Spring-Cloud。"><a href="#14-你熟悉Spring-Cloud吗？请举例说明你在微服务架构中如何使用Spring-Cloud。" class="headerlink" title="14. 你熟悉Spring Cloud吗？请举例说明你在微服务架构中如何使用Spring Cloud。"></a>14. 你熟悉Spring Cloud吗？请举例说明你在微服务架构中如何使用Spring Cloud。</h3><ul><li>我熟悉Spring Cloud，它是一套用于构建微服务架构的工具集，包括服务发现（Eureka）、配置管理（Config）、负载均衡（Ribbon）等。</li><li>在一个微服务项目中，我使用Eureka作为服务注册中心，各个微服务在启动时向Eureka注册，服务之间通过Ribbon进行负载均衡调用。此外，我还使用Spring Cloud Config来集中管理各个微服务的配置。</li></ul><h3 id="15-你如何理解前端框架Vue？请举例说明你在项目中如何使用Vue。"><a href="#15-你如何理解前端框架Vue？请举例说明你在项目中如何使用Vue。" class="headerlink" title="15. 你如何理解前端框架Vue？请举例说明你在项目中如何使用Vue。"></a>15. 你如何理解前端框架Vue？请举例说明你在项目中如何使用Vue。</h3><ul><li>Vue是一个渐进式JavaScript框架，用于构建用户界面。它采用组件化开发模式，数据驱动视图更新。</li><li>在一个后台管理系统中，我使用Vue构建了前端页面。通过Vue的组件化开发，我将页面拆分为多个可复用的组件，如导航栏、表格、表单等。同时，我使用Vuex进行状态管理，确保各个组件之间的数据共享和同步。</li></ul><h3 id="16-面向对象编程（OOP）的三大特性是："><a href="#16-面向对象编程（OOP）的三大特性是：" class="headerlink" title="16.面向对象编程（OOP）的三大特性是："></a>16.面向对象编程（OOP）的三大特性是：</h3><p>(1) 封装（Encapsulation）：</p><ul><li>将数据和操作数据的方法绑定，隐藏内部实现，仅通过接口与外界交互。</li><li>优点：提高代码安全性，便于维护和复用。</li></ul><p>(2) 继承（Inheritance）：</p><ul><li>子类继承父类的属性和方法，并可扩展或重写。</li><li>优点：减少代码重复，增强可扩展性。</li></ul><p>(3) 多态（Polymorphism）：</p><ul><li>同一操作在不同对象上有不同表现，通常通过方法重写和接口实现。</li><li>优点：提高代码灵活性和可扩展性。</li></ul><h3 id="17-单例模式实现方式："><a href="#17-单例模式实现方式：" class="headerlink" title="17.单例模式实现方式："></a>17.单例模式实现方式：</h3><p>(1) 懒汉式（Lazy Initialization）：在第一次调用时创建实例。</p><ul><li>优点：延迟加载，节省资源。</li><li>缺点：非线程安全，多线程环境下可能创建多个实例。</li></ul><p>(2) 饿汉式（Eager Initialization）：在类加载时创建实例。</p><ul><li>优点：线程安全，实现简单。</li><li>缺点：类加载时就创建实例，可能浪费资源。</li></ul><p>(3) 静态内部类（Static Inner Class）：利用类加载机制保证线程安全，同时实现延迟加载。</p><ul><li>优点：线程安全，延迟加载，实现简单。</li><li>缺点：无法传递参数初始化实例。</li></ul><h3 id="18-MySQL索引"><a href="#18-MySQL索引" class="headerlink" title="18.MySQL索引"></a>18.MySQL索引</h3><p>（1）按数据结构分类</p><ul><li>B+Tree 索引：<ul><li>MySQL 默认的索引类型，适用于全键值、键值范围和键值前缀查询。</li><li>支持 &#x3D;、&gt;、&lt;、BETWEEN、IN 等操作。</li></ul></li><li>Hash 索引：<ul><li>基于哈希表实现，适用于等值查询（&#x3D;），不支持范围查询。</li><li>内存存储引擎（如 MEMORY）支持 Hash 索引。</li></ul></li><li>全文索引（FULLTEXT）：<ul><li>用于全文搜索，适用于 MATCH AGAINST 操作。</li><li>仅支持 InnoDB 和 MyISAM 存储引擎。</li></ul></li><li>空间索引（R-Tree）：<ul><li>用于地理空间数据，支持几何数据类型。<br>（2）按功能分类</li></ul></li><li>普通索引（INDEX）：<ul><li>最基本的索引，没有任何约束。</li></ul></li><li>唯一索引（UNIQUE INDEX）：<ul><li>确保索引列的值唯一，允许有空值。</li></ul></li><li>主键索引（PRIMARY KEY）：<ul><li>特殊的唯一索引，不允许有空值，每个表只能有一个主键。</li></ul></li><li>组合索引（复合索引）：<ul><li>对多个列联合创建的索引，遵循最左前缀原则。</li></ul></li><li>前缀索引：<ul><li>对列的前缀部分创建索引，节省存储空间。</li></ul></li></ul><h3 id="19-MySQL表常见连接方式"><a href="#19-MySQL表常见连接方式" class="headerlink" title="19.MySQL表常见连接方式"></a>19.MySQL表常见连接方式</h3><p>(1) LEFT JOIN（左连接）</p><ul><li>定义：以左表（LEFT JOIN 左侧的表）为基准，返回左表的所有行，即使右表中没有匹配的行。</li><li>结果：<ul><li>如果右表有匹配的行，则返回匹配的数据。</li><li>如果右表没有匹配的行，则右表的列返回NULL。</li></ul></li></ul><p>(2) RIGHT JOIN（右连接）</p><ul><li>定义：以右表（RIGHT JOIN 右侧的表）为基准，返回右表的所有行，即使左表中没有匹配的行。</li><li>结果：<ul><li>如果左表有匹配的行，则返回匹配的数据。</li><li>如果左表没有匹配的行，则左表的列返回 NULL。</li></ul></li></ul><p>(3) INNER JOIN（内连接）</p><ul><li>定义：返回两个表中匹配的行。如果某一行在其中一个表中没有匹配，则不会返回该行。</li></ul><p>(4) FULL OUTER JOIN（全外连接）</p><ul><li>定义：返回两个表中所有行，无论是否匹配。如果某一行在其中一个表中没有匹配，则缺失的部分用 NULL 填充。</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>Java</tag>
      
      <tag>Vue</tag>
      
      <tag>MyBatis</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring生态</title>
    <link href="/2025/02/17/Spring%E7%94%9F%E6%80%81/"/>
    <url>/2025/02/17/Spring%E7%94%9F%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Spring-Boot"><a href="#一、Spring-Boot" class="headerlink" title="一、Spring Boot"></a>一、Spring Boot</h2><h3 id="1-核心注解"><a href="#1-核心注解" class="headerlink" title="1. 核心注解"></a>1. 核心注解</h3><ul><li>@Component: 标记一个类为 Spring 容器管理的组件，通用的注解。</li><li>@Service: 标记一个类为服务层组件，通常用于业务逻辑层。</li><li>@Repository: 标记一个类为数据访问层组件，通常用于 DAO 层。</li><li>@Controller: 标记一个类为控制器组件，通常用于 MVC 模式中的控制器。</li><li>@RestController: 结合了 @Controller 和 @ResponseBody，用于 RESTful Web 服务。</li></ul><h3 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2. 依赖注入"></a>2. 依赖注入</h3><ul><li>@Autowired: 自动注入依赖，可以用于字段、构造器或方法。</li><li>@Qualifier: 与 @Autowired 一起使用，指定要注入的 bean 的名称。</li><li>@Resource: 类似于 @Autowired，但按名称注入。</li><li>@Value: 注入属性值，通常用于从配置文件中读取值。</li></ul><h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h3><ul><li>@Configuration: 标记一个类为配置类，通常与 @Bean 一起使用。</li><li>@Bean: 标记一个方法返回的对象为 Spring 容器管理的 bean。</li><li>@ComponentScan: 指定 Spring 扫描组件的包路径。</li><li>@PropertySource: 指定属性文件的位置，用于加载配置。</li></ul><h3 id="4-AOP（面向切面编程）"><a href="#4-AOP（面向切面编程）" class="headerlink" title="4. AOP（面向切面编程）"></a>4. AOP（面向切面编程）</h3><ul><li>@Aspect: 标记一个类为切面类。</li><li>@Before: 在目标方法执行前执行。</li><li>@After: 在目标方法执行后执行，无论是否抛出异常。</li><li>@AfterReturning: 在目标方法成功返回后执行。</li><li>@AfterThrowing: 在目标方法抛出异常后执行。</li><li>@Around: 环绕通知，可以在目标方法执行前后执行自定义逻辑。</li></ul><h3 id="5-事务管理"><a href="#5-事务管理" class="headerlink" title="5. 事务管理"></a>5. 事务管理</h3><ul><li>@Transactional: 标记一个方法或类为事务性的，用于声明式事务管理。</li></ul><h2 id="二、Mybatis"><a href="#二、Mybatis" class="headerlink" title="二、Mybatis"></a>二、Mybatis</h2><h3 id="1-什么是MyBatis？"><a href="#1-什么是MyBatis？" class="headerlink" title="1. 什么是MyBatis？"></a>1. 什么是MyBatis？</h3><p>MyBatis是一个基于Java的持久层框架，它封装了JDBC操作，简化了数据库访问。MyBatis通过XML或注解将Java对象与SQL语句进行映射，开发者可以直接编写SQL语句，灵活地控制查询逻辑。</p><h3 id="2-MyBatis的核心组件有哪些？"><a href="#2-MyBatis的核心组件有哪些？" class="headerlink" title="2. MyBatis的核心组件有哪些？"></a>2. MyBatis的核心组件有哪些？</h3><ul><li>SqlSessionFactory：用于创建SqlSession的工厂类，是MyBatis的核心对象。</li><li>SqlSession：表示一次数据库会话，用于执行SQL语句、获取Mapper接口。</li><li>Mapper接口：定义了数据库操作的方法，MyBatis通过动态代理实现接口。</li><li>Mapper XML文件：定义了SQL语句和结果映射规则。</li><li>Configuration：包含了MyBatis的全局配置信息。</li></ul><h3 id="3-MyBatis中-和-的区别是什么？"><a href="#3-MyBatis中-和-的区别是什么？" class="headerlink" title="3. MyBatis中#{}和${}的区别是什么？"></a>3. MyBatis中#{}和${}的区别是什么？</h3><ul><li>#{}：<ul><li>是预编译占位符，MyBatis会将#{}替换为?，并通过PreparedStatement设置参数，防止SQL注入。</li><li>适用于传递参数值。</li></ul></li><li>${}：<ul><li>是字符串替换，MyBatis会直接将${}替换为变量的值，存在SQL注入风险。</li><li>适用于动态表名、列名等场景。</li></ul></li></ul><h3 id="4-MyBatis如何实现分页？"><a href="#4-MyBatis如何实现分页？" class="headerlink" title="4. MyBatis如何实现分页？"></a>4. MyBatis如何实现分页？</h3><ul><li>逻辑分页：使用MyBatis的RowBounds对象，在内存中进行分页，适合数据量小的场景。</li><li>物理分页：在SQL语句中使用LIMIT和OFFSET（MySQL）或ROWNUM（Oracle）实现分页。</li><li>分页插件：使用PageHelper等分页插件，简化分页操作。</li></ul><h3 id="5-MyBatis的一级缓存和二级缓存有什么区别？"><a href="#5-MyBatis的一级缓存和二级缓存有什么区别？" class="headerlink" title="5. MyBatis的一级缓存和二级缓存有什么区别？"></a>5. MyBatis的一级缓存和二级缓存有什么区别？</h3><ul><li>一级缓存：<ul><li>默认开启，作用域为SqlSession级别。</li><li>在同一个SqlSession中，相同的查询会直接从缓存中获取结果。</li><li>当SqlSession关闭或执行增删改操作时，缓存会被清空。</li></ul></li><li>二级缓存：<ul><li>需要手动开启，作用域为Mapper级别（跨SqlSession）。</li><li>多个SqlSession可以共享二级缓存。</li><li>适合读取频繁、更新较少的场景。</li></ul></li></ul><h3 id="6-MyBatis如何实现多表关联查询？"><a href="#6-MyBatis如何实现多表关联查询？" class="headerlink" title="6. MyBatis如何实现多表关联查询？"></a>6. MyBatis如何实现多表关联查询？</h3><ul><li>嵌套查询：在主查询中通过&lt; association &gt;或&lt; collection &gt;标签嵌套子查询。</li><li>嵌套结果：通过JOIN查询一次性获取所有数据，然后在结果映射中使用&lt; association &gt;或&lt; collection &gt;标签映射关联对象。</li></ul><h3 id="7-MyBatis的动态SQL有哪些标签？"><a href="#7-MyBatis的动态SQL有哪些标签？" class="headerlink" title="7. MyBatis的动态SQL有哪些标签？"></a>7. MyBatis的动态SQL有哪些标签？</h3><ul><li>&lt; if &gt;： 条件判断。</li><li>&lt; choose &gt;、&lt; when &gt;、&lt; otherwise &gt;： 多条件选择。</li><li>&lt; where &gt;： 动态生成WHERE子句。</li><li>&lt; set &gt;： 动态生成SET子句。</li><li>&lt; foreach &gt;： 遍历集合，生成IN语句或批量操作。</li><li>&lt; trim &gt;： 去除多余的字符（如AND、OR）。</li></ul><h3 id="8-MyBatis如何实现批量插入？"><a href="#8-MyBatis如何实现批量插入？" class="headerlink" title="8. MyBatis如何实现批量插入？"></a>8. MyBatis如何实现批量插入？</h3><ul><li>使用&lt; foreach &gt;标签遍历集合，生成多条INSERT语句。</li><li>使用SqlSession的batch方法实现批量操作。</li></ul><h3 id="9-MyBatis如何解决SQL注入问题？"><a href="#9-MyBatis如何解决SQL注入问题？" class="headerlink" title="9. MyBatis如何解决SQL注入问题？"></a>9. MyBatis如何解决SQL注入问题？</h3><ul><li>使用#{}预编译占位符，避免直接拼接SQL。</li><li>避免使用${}进行字符串替换，除非是动态表名、列名等场景。</li><li>对用户输入进行严格的校验和过滤。</li></ul><h2 id="三、Spring-Cloud"><a href="#三、Spring-Cloud" class="headerlink" title="三、Spring Cloud"></a>三、Spring Cloud</h2><h3 id="1-服务注册与发现"><a href="#1-服务注册与发现" class="headerlink" title="1. 服务注册与发现"></a>1. 服务注册与发现</h3><ul><li>@EnableEurekaClient: 启用 Eureka 客户端，将服务注册到 Eureka 服务器。</li><li>@EnableDiscoveryClient: 启用服务发现客户端，适用于多种服务发现工具（如 Eureka、Consul、Zookeeper）。</li><li>@LoadBalanced: 标记 RestTemplate 或 WebClient，使其具备负载均衡能力。</li></ul><h3 id="2-配置管理"><a href="#2-配置管理" class="headerlink" title="2. 配置管理"></a>2. 配置管理</h3><ul><li>@EnableConfigServer: 启用配置服务器，集中管理微服务的配置。</li><li>@RefreshScope: 标记 Bean，使其在配置更改时能够动态刷新。</li></ul><h3 id="3-API-网关"><a href="#3-API-网关" class="headerlink" title="3. API 网关"></a>3. API 网关</h3><ul><li>@EnableZuulProxy: 启用 Zuul 代理，用于 API 网关路由和过滤。</li><li>@EnableZuulServer: 启用 Zuul 服务器，提供基本的网关功能。</li><li>@EnableGateway: 启用 Spring Cloud Gateway，提供更强大的 API 网关功能。</li></ul><h3 id="4-熔断器与限流"><a href="#4-熔断器与限流" class="headerlink" title="4. 熔断器与限流"></a>4. 熔断器与限流</h3><ul><li>@EnableHystrix: 启用 Hystrix 熔断器，提供容错和延迟容忍能力。</li><li>@HystrixCommand: 标记方法，使其具备熔断器功能。</li><li>@EnableCircuitBreaker: 启用熔断器功能，适用于多种熔断器实现（如 Hystrix、Resilience4j）。</li><li>@SentinelResource: 标记方法，使其具备 Sentinel 的限流和熔断功能。</li></ul><h3 id="5-分布式追踪"><a href="#5-分布式追踪" class="headerlink" title="5. 分布式追踪"></a>5. 分布式追踪</h3><ul><li>@EnableSleuth: 启用 Sleuth，提供分布式追踪功能。</li><li>@NewSpan: 标记方法，使其在追踪中创建一个新的 Span。</li></ul><h3 id="6-消息驱动"><a href="#6-消息驱动" class="headerlink" title="6. 消息驱动"></a>6. 消息驱动</h3><ul><li>@EnableBinding: 启用消息绑定，将应用程序与消息中间件（如 Kafka、RabbitMQ）连接。</li><li>@StreamListener: 标记方法，使其监听消息通道中的消息。</li></ul><h2 id="四、Spring-Security"><a href="#四、Spring-Security" class="headerlink" title="四、Spring Security"></a>四、Spring Security</h2><h3 id="1-EnableWebSecurity"><a href="#1-EnableWebSecurity" class="headerlink" title="1.@EnableWebSecurity"></a>1.@EnableWebSecurity</h3><ul><li>启用 Spring Security 的 Web 安全支持。</li><li>通常用于配置类上，表示该类是 Spring Security 的配置类。</li></ul><h3 id="2-PreAuthorize"><a href="#2-PreAuthorize" class="headerlink" title="2.@PreAuthorize"></a>2.@PreAuthorize</h3><ul><li>在方法执行前进行权限检查。</li><li>支持 SpEL（Spring Expression Language）表达式。</li></ul><h3 id="3-Secured"><a href="#3-Secured" class="headerlink" title="3.@Secured"></a>3.@Secured</h3><ul><li>用于指定方法所需的角色。</li><li>不支持 SpEL，仅支持简单的角色名称。</li></ul><h3 id="4-WithAnonymousUser"><a href="#4-WithAnonymousUser" class="headerlink" title="4.@WithAnonymousUser"></a>4.@WithAnonymousUser</h3><ul><li>用于测试，模拟匿名用户。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>Spring Boot</tag>
      
      <tag>Mybatis</tag>
      
      <tag>Spring Cloud</tag>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库基础</title>
    <link href="/2025/01/12/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/01/12/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一、SQL通用语法"><a href="#一、SQL通用语法" class="headerlink" title="一、SQL通用语法"></a><strong>一、SQL通用语法</strong></h2><p>1.SQL语句可以单行或多行书写，以分号结尾<br>2.SQL语句可以使用空格&#x2F;缩进来增强语句的可读性<br>3.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写<br>4.注释：</p><ul><li>单行注释：–注释内容 或 #注释内容（MySQL特有）</li><li>多行注释：&#x2F;* 注释内容 *&#x2F;</li></ul><h2 id="二、DDL（数据定义语言）"><a href="#二、DDL（数据定义语言）" class="headerlink" title="二、DDL（数据定义语言）"></a><strong>二、DDL（数据定义语言）</strong></h2><h3 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1.数据库操作"></a>1.数据库操作</h3><p>(1).查询</p><ul><li>查询所有数据库：SHOW DATABASES;</li><li>查询当前数据库：SELECT DATABASE();</li></ul><p>(2).创建</p><ul><li>CREATE DATABASE [ IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]；</li></ul><p>(3).删除</p><ul><li>DROP DATABASE [IF EXISTS] 数据库名；</li></ul><p>(4).使用</p><ul><li>USE 数据库名；</li></ul><h3 id="2-表操作"><a href="#2-表操作" class="headerlink" title="2.表操作"></a>2.表操作</h3><p>(1).查询</p><ul><li>查询当前数据库所有表：SHOW TABLES;</li><li>查询表结构：DESC 表名；</li><li>查询指定表的建表语句：SHOW CREATE TABLE 表名；</li></ul><p>(2).创建</p><ul><li>CREATE TABLE 表名（<br>字段1 字段1类型[COMMENT 字段1注释],<br>字段2 字段2类型[COMMENT 字段2注释],<br>字段3 字段3类型[COMMENT 字段3注释],<br>…….<br>字段n 字段n类型[COMMENT 字段n注释]<br>   ）[COMMENT 表注释]；</li></ul><p><span style="color:#FF6B6B">注：最后一个字段后面没有逗号</span></p><p>(3).修改</p><ul><li>添加：ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束]；</li><li>修改：<ul><li>修改数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度)；</li><li>修改字段名和字段类型：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]；</li><li>删除字段：ALTER TABLE 表名 DROP 字段名；</li><li>修改表名：ALTER TABLE 表名 RENAME TO 新表名；</li></ul></li></ul><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h3><p>(1).数值类型：</p><blockquote><p>TINYINT：1 byte<br>  SMALLINT：2 bytes<br>  MEDIUMINT：3 bytes<br>  INT或INTEGER：4 bytes<br>  BIGINT：8 bytes<br>  FLOAT：4 bytes<br>  DOUBLE：8 bytes<br>  DECIMAL：依赖于M（精度）和 D（标度）的值</p></blockquote><p><span style="color:#FF6B6B">注：UNSIGNED表明无符号，即不能为负(例：age tinyint unsigned)</span></p><p>(2).字符串类型：</p><blockquote><p>CHAR：0-255 bytes 定长字符串<br>  VARCHAR：0-65535 bytes 变长字符串<br>  TINYBLOB：0-255 bytes 不超过255个字符的二进制数据<br>  TINYTEXT：0-255 bytes 短文本字符串<br>  BLOB：0-65535 bytes 二进制长文本数据<br>  TEXT：0-65535 bytes 长文本数据<br>  MEDIUMBLOB：0-16777215 bytes 二进制形式的中等长度文本数据<br>  MEDIUMTEXT：0-16777215 bytes 中等长度文本数据<br>  LONGBLOB：0-4294967295 bytes 二进制形式的极大文本数据<br>  LONGTEXT：0-4294967295 bytes 极大文本数据</p></blockquote><p><span style="color:#FF6B6B">注：CHAR和VARCHAR区别：假设声明char(10)和varchar(10)，char即便存储1个字符也会占用10个字符的空间，未占用的空间会用空格填充；varchar存储1个字符就占用1个字符的空间，会根据你存储的内容去计算所需空间。所以char的性能更好，而varchar更省内存</span></p><p>(3).日期类型：</p><blockquote><p>DATE：YYYY-MM-DD 日期值<br>  TIME：HH:MM:SS 时间值或持续时间<br>  YEAR：YYYY 年份值<br>  DATETIME：YYYY-MM-DD HH:MM:SS 混合日期和时间值<br>  TIMESTAMP：YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳</p></blockquote><h2 id="三、DML（数据操作语言）"><a href="#三、DML（数据操作语言）" class="headerlink" title="三、DML（数据操作语言）"></a><strong>三、DML（数据操作语言）</strong></h2><h3 id="1-添加数据"><a href="#1-添加数据" class="headerlink" title="1.添加数据"></a>1.添加数据</h3><p>(1).给指定字段添加数据：INSERT INTO 表名 (字段1,字段2,…) VALUES(值1,值2,…);<br>(2).给全部字段添加数据：INSERT INTO 表名 VALUES(值1,值2,…);<br>(3).批量添加数据：</p><ul><li>INSERT INTO 表名 (字段名1,字段名2,…) VALUES (值1,值2,…),(值1,值2,…),(值1,值2,…);</li><li>INSERT INTO 表名 VALUES (值1,值2,…),(值1,值2,…),(值1,值2,…);</li></ul><p><span style="color:#FF6B6B">注：</span></p><ul><li><span style="color:#FF6B6B">插入数据时，指定的字段顺序需要与值的顺序是一一对应的</span></li><li><span style="color:#FF6B6B">字符串和日期型数据应该包含在引号中</span></li><li><span style="color:#FF6B6B">插入的数据大小应该在字段的规定范围内</span></li></ul><h3 id="2-修改数据"><a href="#2-修改数据" class="headerlink" title="2.修改数据"></a>2.修改数据</h3><p>(1).修改：UPDATE 表名 SET 字段名1&#x3D;值1,字段名2&#x3D;值2,…[WHERE 条件];<br>(2).删除：DELETE FROM 表名 [WHERE 条件];</p><p><span style="color:#FF6B6B">注：</span></p><ul><li><span style="color:#FF6B6B">DELETE 语句的条件可以有，也可以没有，如果没有条件，就会删除这张表所有数据</span></li><li><span style="color:#FF6B6B">DELETE 语句不能删除某一个字段的值(可以使用UPDATE，直接将该字段修改为null)</span></li></ul><h2 id="四、DQL（数据查询语言）"><a href="#四、DQL（数据查询语言）" class="headerlink" title="四、DQL（数据查询语言）"></a><strong>四、DQL（数据查询语言）</strong></h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h3><p>SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数</p><h3 id="2-基本查询"><a href="#2-基本查询" class="headerlink" title="2.基本查询"></a>2.基本查询</h3><p>(1).查询多个字段：</p><ul><li>SELECT 字段1,字段2,字段3… FROM 表名;</li><li>SELECT * FROM 表名;</li></ul><p>(2).设置别名：SELECT 字段1 [AS 别名1],字段2 [AS 别名2]… FROM 表名;<br>(3).去除重复记录：SELECT DISTINCT 字段列表 FROM 表名;</p><h3 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3.条件查询"></a>3.条件查询</h3><p>(1).语法：SELECT 字段列表 FROM 表名 WHERE 条件列表;<br>(2).条件：</p><ul><li><p>比较运算符</p><blockquote><p><code>&gt;</code>：大于<br> <code>&gt;=</code>：大于等于<br> <code>&lt;</code>：小于<br> <code>&lt;=</code>：小于等于<br><code>=</code>：等于<br> <code>&lt;&gt;</code> 或 <code>!=</code>：不等于<br> <code>BETWEEN...AND...</code>：在某个范围之内（含最小、最大值，<code>BETWEEN</code>后跟最小值，<code>AND</code>后跟最大值）<br> <code>IN(...)</code>：在<code>IN</code>之后的列表中的值，多选一<br> <code>LIKE</code>占位符：模糊匹配（<code>_</code>匹配单个字符，<code>%</code>匹配任意个字符）<br><code>IS NULL</code>：是<code>NULL</code></p></blockquote></li><li><p>逻辑运算符</p><blockquote><p>AND 或 &amp;&amp;：并且（多个条件同时成立）<br>OR 或 ||：或者（多个条件任意一个成立）<br>NOT 或 ！：非，不是</p></blockquote></li></ul><h3 id="4-聚合函数"><a href="#4-聚合函数" class="headerlink" title="4.聚合函数"></a>4.聚合函数</h3><p>(1).介绍：将一列数据作为一个整体，进行纵向计算<br>(2).常见聚合函数</p><blockquote><p>count：统计数量<br>  max：最大值<br>  min：最小值<br>  avg：平均值<br>  sum：求和</p></blockquote><p>(3).语法：SELECT 聚合函数(字段列表) FROM 表名;</p><p><span style="color:#FF6B6B">注：null值不参与所有聚合函数运算</span></p><h3 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5.分组查询"></a>5.分组查询</h3><p>(1).语法：SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];<br>(2).WHERE 与 HAVING区别</p><ul><li>执行时机不同：WHERE是分组前进行过滤，不满足WHERE条件，不参与分组；HAVING是分组后对结果进行过滤</li><li>判断条件不同：WHERE不能对聚合函数进行判断，而HAVING可以</li></ul><h3 id="6-排序查询"><a href="#6-排序查询" class="headerlink" title="6.排序查询"></a>6.排序查询</h3><p>(1).语法：SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;<br>(2).排序方式：</p><ul><li>ASC：升序(默认值)</li><li>DESC：降序</li></ul><p><span style="color:#FF6B6B">注：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</span></p><h3 id="7-分页查询"><a href="#7-分页查询" class="headerlink" title="7.分页查询"></a>7.分页查询</h3><p>(1).语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</p><p><span style="color:#FF6B6B">注：</span></p><ul><li><span style="color:#FF6B6B">起始索引从0开始，起始索引 &#x3D; (查询页码-1) * 每页显示记录数</span></li><li><span style="color:#FF6B6B">分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT</span></li><li><span style="color:#FF6B6B">如果查询的是第一页数据，起始索引可以省略 </span></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
