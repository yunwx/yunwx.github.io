<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring生态</title>
    <link href="/2025/02/17/Spring%E7%94%9F%E6%80%81/"/>
    <url>/2025/02/17/Spring%E7%94%9F%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Spring-Boot"><a href="#一、Spring-Boot" class="headerlink" title="一、Spring Boot"></a>一、Spring Boot</h2><h3 id="1-核心注解"><a href="#1-核心注解" class="headerlink" title="1. 核心注解"></a>1. 核心注解</h3><ul><li>@Component: 标记一个类为 Spring 容器管理的组件，通用的注解。</li><li>@Service: 标记一个类为服务层组件，通常用于业务逻辑层。</li><li>@Repository: 标记一个类为数据访问层组件，通常用于 DAO 层。</li><li>@Controller: 标记一个类为控制器组件，通常用于 MVC 模式中的控制器。</li><li>@RestController: 结合了 @Controller 和 @ResponseBody，用于 RESTful Web 服务。</li></ul><h3 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2. 依赖注入"></a>2. 依赖注入</h3><ul><li>@Autowired: 自动注入依赖，可以用于字段、构造器或方法。</li><li>@Qualifier: 与 @Autowired 一起使用，指定要注入的 bean 的名称。</li><li>@Resource: 类似于 @Autowired，但按名称注入。</li><li>@Value: 注入属性值，通常用于从配置文件中读取值。</li></ul><h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h3><ul><li>@Configuration: 标记一个类为配置类，通常与 @Bean 一起使用。</li><li>@Bean: 标记一个方法返回的对象为 Spring 容器管理的 bean。</li><li>@ComponentScan: 指定 Spring 扫描组件的包路径。</li><li>@PropertySource: 指定属性文件的位置，用于加载配置。</li></ul><h3 id="4-AOP（面向切面编程）"><a href="#4-AOP（面向切面编程）" class="headerlink" title="4. AOP（面向切面编程）"></a>4. AOP（面向切面编程）</h3><ul><li>@Aspect: 标记一个类为切面类。</li><li>@Before: 在目标方法执行前执行。</li><li>@After: 在目标方法执行后执行，无论是否抛出异常。</li><li>@AfterReturning: 在目标方法成功返回后执行。</li><li>@AfterThrowing: 在目标方法抛出异常后执行。</li><li>@Around: 环绕通知，可以在目标方法执行前后执行自定义逻辑。</li></ul><h3 id="5-事务管理"><a href="#5-事务管理" class="headerlink" title="5. 事务管理"></a>5. 事务管理</h3><ul><li>@Transactional: 标记一个方法或类为事务性的，用于声明式事务管理。</li></ul><h2 id="二、Mybatis"><a href="#二、Mybatis" class="headerlink" title="二、Mybatis"></a>二、Mybatis</h2><h3 id="1-什么是MyBatis？"><a href="#1-什么是MyBatis？" class="headerlink" title="1. 什么是MyBatis？"></a>1. 什么是MyBatis？</h3><p>MyBatis是一个基于Java的持久层框架，它封装了JDBC操作，简化了数据库访问。MyBatis通过XML或注解将Java对象与SQL语句进行映射，开发者可以直接编写SQL语句，灵活地控制查询逻辑。</p><h3 id="2-MyBatis的核心组件有哪些？"><a href="#2-MyBatis的核心组件有哪些？" class="headerlink" title="2. MyBatis的核心组件有哪些？"></a>2. MyBatis的核心组件有哪些？</h3><ul><li>SqlSessionFactory：用于创建SqlSession的工厂类，是MyBatis的核心对象。</li><li>SqlSession：表示一次数据库会话，用于执行SQL语句、获取Mapper接口。</li><li>Mapper接口：定义了数据库操作的方法，MyBatis通过动态代理实现接口。</li><li>Mapper XML文件：定义了SQL语句和结果映射规则。</li><li>Configuration：包含了MyBatis的全局配置信息。</li></ul><h3 id="3-MyBatis中-和-的区别是什么？"><a href="#3-MyBatis中-和-的区别是什么？" class="headerlink" title="3. MyBatis中#{}和${}的区别是什么？"></a>3. MyBatis中#{}和${}的区别是什么？</h3><ul><li>#{}：<ul><li>是预编译占位符，MyBatis会将#{}替换为?，并通过PreparedStatement设置参数，防止SQL注入。</li><li>适用于传递参数值。</li></ul></li><li>${}：<ul><li>是字符串替换，MyBatis会直接将${}替换为变量的值，存在SQL注入风险。</li><li>适用于动态表名、列名等场景。</li></ul></li></ul><h3 id="4-MyBatis如何实现分页？"><a href="#4-MyBatis如何实现分页？" class="headerlink" title="4. MyBatis如何实现分页？"></a>4. MyBatis如何实现分页？</h3><ul><li>逻辑分页：使用MyBatis的RowBounds对象，在内存中进行分页，适合数据量小的场景。</li><li>物理分页：在SQL语句中使用LIMIT和OFFSET（MySQL）或ROWNUM（Oracle）实现分页。</li><li>分页插件：使用PageHelper等分页插件，简化分页操作。</li></ul><h3 id="5-MyBatis的一级缓存和二级缓存有什么区别？"><a href="#5-MyBatis的一级缓存和二级缓存有什么区别？" class="headerlink" title="5. MyBatis的一级缓存和二级缓存有什么区别？"></a>5. MyBatis的一级缓存和二级缓存有什么区别？</h3><ul><li>一级缓存：<ul><li>默认开启，作用域为SqlSession级别。</li><li>在同一个SqlSession中，相同的查询会直接从缓存中获取结果。</li><li>当SqlSession关闭或执行增删改操作时，缓存会被清空。</li></ul></li><li>二级缓存：<ul><li>需要手动开启，作用域为Mapper级别（跨SqlSession）。</li><li>多个SqlSession可以共享二级缓存。</li><li>适合读取频繁、更新较少的场景。</li></ul></li></ul><h3 id="6-MyBatis如何实现多表关联查询？"><a href="#6-MyBatis如何实现多表关联查询？" class="headerlink" title="6. MyBatis如何实现多表关联查询？"></a>6. MyBatis如何实现多表关联查询？</h3><ul><li>嵌套查询：在主查询中通过&lt; association &gt;或&lt; collection &gt;标签嵌套子查询。</li><li>嵌套结果：通过JOIN查询一次性获取所有数据，然后在结果映射中使用&lt; association &gt;或&lt; collection &gt;标签映射关联对象。</li></ul><h3 id="7-MyBatis的动态SQL有哪些标签？"><a href="#7-MyBatis的动态SQL有哪些标签？" class="headerlink" title="7. MyBatis的动态SQL有哪些标签？"></a>7. MyBatis的动态SQL有哪些标签？</h3><ul><li>&lt; if &gt;： 条件判断。</li><li>&lt; choose &gt;、&lt; when &gt;、&lt; otherwise &gt;： 多条件选择。</li><li>&lt; where &gt;： 动态生成WHERE子句。</li><li>&lt; set &gt;： 动态生成SET子句。</li><li>&lt; foreach &gt;： 遍历集合，生成IN语句或批量操作。</li><li>&lt; trim &gt;： 去除多余的字符（如AND、OR）。</li></ul><h3 id="8-MyBatis如何实现批量插入？"><a href="#8-MyBatis如何实现批量插入？" class="headerlink" title="8. MyBatis如何实现批量插入？"></a>8. MyBatis如何实现批量插入？</h3><ul><li>使用&lt; foreach &gt;标签遍历集合，生成多条INSERT语句。</li><li>使用SqlSession的batch方法实现批量操作。</li></ul><h3 id="9-MyBatis如何解决SQL注入问题？"><a href="#9-MyBatis如何解决SQL注入问题？" class="headerlink" title="9. MyBatis如何解决SQL注入问题？"></a>9. MyBatis如何解决SQL注入问题？</h3><ul><li>使用#{}预编译占位符，避免直接拼接SQL。</li><li>避免使用${}进行字符串替换，除非是动态表名、列名等场景。</li><li>对用户输入进行严格的校验和过滤。</li></ul><h2 id="三、Spring-Cloud"><a href="#三、Spring-Cloud" class="headerlink" title="三、Spring Cloud"></a>三、Spring Cloud</h2><h3 id="1-服务注册与发现"><a href="#1-服务注册与发现" class="headerlink" title="1. 服务注册与发现"></a>1. 服务注册与发现</h3><ul><li>@EnableEurekaClient: 启用 Eureka 客户端，将服务注册到 Eureka 服务器。</li><li>@EnableDiscoveryClient: 启用服务发现客户端，适用于多种服务发现工具（如 Eureka、Consul、Zookeeper）。</li><li>@LoadBalanced: 标记 RestTemplate 或 WebClient，使其具备负载均衡能力。</li></ul><h3 id="2-配置管理"><a href="#2-配置管理" class="headerlink" title="2. 配置管理"></a>2. 配置管理</h3><ul><li>@EnableConfigServer: 启用配置服务器，集中管理微服务的配置。</li><li>@RefreshScope: 标记 Bean，使其在配置更改时能够动态刷新。</li></ul><h3 id="3-API-网关"><a href="#3-API-网关" class="headerlink" title="3. API 网关"></a>3. API 网关</h3><ul><li>@EnableZuulProxy: 启用 Zuul 代理，用于 API 网关路由和过滤。</li><li>@EnableZuulServer: 启用 Zuul 服务器，提供基本的网关功能。</li><li>@EnableGateway: 启用 Spring Cloud Gateway，提供更强大的 API 网关功能。</li></ul><h3 id="4-熔断器与限流"><a href="#4-熔断器与限流" class="headerlink" title="4. 熔断器与限流"></a>4. 熔断器与限流</h3><ul><li>@EnableHystrix: 启用 Hystrix 熔断器，提供容错和延迟容忍能力。</li><li>@HystrixCommand: 标记方法，使其具备熔断器功能。</li><li>@EnableCircuitBreaker: 启用熔断器功能，适用于多种熔断器实现（如 Hystrix、Resilience4j）。</li><li>@SentinelResource: 标记方法，使其具备 Sentinel 的限流和熔断功能。</li></ul><h3 id="5-分布式追踪"><a href="#5-分布式追踪" class="headerlink" title="5. 分布式追踪"></a>5. 分布式追踪</h3><ul><li>@EnableSleuth: 启用 Sleuth，提供分布式追踪功能。</li><li>@NewSpan: 标记方法，使其在追踪中创建一个新的 Span。</li></ul><h3 id="6-消息驱动"><a href="#6-消息驱动" class="headerlink" title="6. 消息驱动"></a>6. 消息驱动</h3><ul><li>@EnableBinding: 启用消息绑定，将应用程序与消息中间件（如 Kafka、RabbitMQ）连接。</li><li>@StreamListener: 标记方法，使其监听消息通道中的消息。</li></ul><h2 id="四、Spring-Security"><a href="#四、Spring-Security" class="headerlink" title="四、Spring Security"></a>四、Spring Security</h2><h3 id="1-EnableWebSecurity"><a href="#1-EnableWebSecurity" class="headerlink" title="1.@EnableWebSecurity"></a>1.@EnableWebSecurity</h3><ul><li>启用 Spring Security 的 Web 安全支持。</li><li>通常用于配置类上，表示该类是 Spring Security 的配置类。</li></ul><h3 id="2-PreAuthorize"><a href="#2-PreAuthorize" class="headerlink" title="2.@PreAuthorize"></a>2.@PreAuthorize</h3><ul><li>在方法执行前进行权限检查。</li><li>支持 SpEL（Spring Expression Language）表达式。</li></ul><h3 id="3-Secured"><a href="#3-Secured" class="headerlink" title="3.@Secured"></a>3.@Secured</h3><ul><li>用于指定方法所需的角色。</li><li>不支持 SpEL，仅支持简单的角色名称。</li></ul><h3 id="4-WithAnonymousUser"><a href="#4-WithAnonymousUser" class="headerlink" title="4.@WithAnonymousUser"></a>4.@WithAnonymousUser</h3><ul><li>用于测试，模拟匿名用户。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库基础</title>
    <link href="/2025/01/12/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/01/12/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一、SQL通用语法"><a href="#一、SQL通用语法" class="headerlink" title="一、SQL通用语法"></a><strong>一、SQL通用语法</strong></h2><p>1.SQL语句可以单行或多行书写，以分号结尾<br>2.SQL语句可以使用空格&#x2F;缩进来增强语句的可读性<br>3.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写<br>4.注释：</p><ul><li>单行注释：–注释内容 或 #注释内容（MySQL特有）</li><li>多行注释：&#x2F;* 注释内容 *&#x2F;</li></ul><h2 id="二、DDL（数据定义语言）"><a href="#二、DDL（数据定义语言）" class="headerlink" title="二、DDL（数据定义语言）"></a><strong>二、DDL（数据定义语言）</strong></h2><h3 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1.数据库操作"></a>1.数据库操作</h3><p>(1).查询</p><ul><li>查询所有数据库：SHOW DATABASES;</li><li>查询当前数据库：SELECT DATABASE();</li></ul><p>(2).创建</p><ul><li>CREATE DATABASE [ IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]；</li></ul><p>(3).删除</p><ul><li>DROP DATABASE [IF EXISTS] 数据库名；</li></ul><p>(4).使用</p><ul><li>USE 数据库名；</li></ul><h3 id="2-表操作"><a href="#2-表操作" class="headerlink" title="2.表操作"></a>2.表操作</h3><p>(1).查询</p><ul><li>查询当前数据库所有表：SHOW TABLES;</li><li>查询表结构：DESC 表名；</li><li>查询指定表的建表语句：SHOW CREATE TABLE 表名；</li></ul><p>(2).创建</p><ul><li>CREATE TABLE 表名（<br>字段1 字段1类型[COMMENT 字段1注释],<br>字段2 字段2类型[COMMENT 字段2注释],<br>字段3 字段3类型[COMMENT 字段3注释],<br>…….<br>字段n 字段n类型[COMMENT 字段n注释]<br>   ）[COMMENT 表注释]；</li></ul><p><span style="color:#FF6B6B">注：最后一个字段后面没有逗号</span></p><p>(3).修改</p><ul><li>添加：ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束]；</li><li>修改：<ul><li>修改数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度)；</li><li>修改字段名和字段类型：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]；</li><li>删除字段：ALTER TABLE 表名 DROP 字段名；</li><li>修改表名：ALTER TABLE 表名 RENAME TO 新表名；</li></ul></li></ul><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h3><p>(1).数值类型：</p><blockquote><p>TINYINT：1 byte<br>  SMALLINT：2 bytes<br>  MEDIUMINT：3 bytes<br>  INT或INTEGER：4 bytes<br>  BIGINT：8 bytes<br>  FLOAT：4 bytes<br>  DOUBLE：8 bytes<br>  DECIMAL：依赖于M（精度）和 D（标度）的值</p></blockquote><p><span style="color:#FF6B6B">注：UNSIGNED表明无符号，即不能为负(例：age tinyint unsigned)</span></p><p>(2).字符串类型：</p><blockquote><p>CHAR：0-255 bytes 定长字符串<br>  VARCHAR：0-65535 bytes 变长字符串<br>  TINYBLOB：0-255 bytes 不超过255个字符的二进制数据<br>  TINYTEXT：0-255 bytes 短文本字符串<br>  BLOB：0-65535 bytes 二进制长文本数据<br>  TEXT：0-65535 bytes 长文本数据<br>  MEDIUMBLOB：0-16777215 bytes 二进制形式的中等长度文本数据<br>  MEDIUMTEXT：0-16777215 bytes 中等长度文本数据<br>  LONGBLOB：0-4294967295 bytes 二进制形式的极大文本数据<br>  LONGTEXT：0-4294967295 bytes 极大文本数据</p></blockquote><p><span style="color:#FF6B6B">注：CHAR和VARCHAR区别：假设声明char(10)和varchar(10)，char即便存储1个字符也会占用10个字符的空间，未占用的空间会用空格填充；varchar存储1个字符就占用1个字符的空间，会根据你存储的内容去计算所需空间。所以char的性能更好，而varchar更省内存</span></p><p>(3).日期类型：</p><blockquote><p>DATE：YYYY-MM-DD 日期值<br>  TIME：HH:MM:SS 时间值或持续时间<br>  YEAR：YYYY 年份值<br>  DATETIME：YYYY-MM-DD HH:MM:SS 混合日期和时间值<br>  TIMESTAMP：YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳</p></blockquote><h2 id="三、DML（数据操作语言）"><a href="#三、DML（数据操作语言）" class="headerlink" title="三、DML（数据操作语言）"></a><strong>三、DML（数据操作语言）</strong></h2><h3 id="1-添加数据"><a href="#1-添加数据" class="headerlink" title="1.添加数据"></a>1.添加数据</h3><p>(1).给指定字段添加数据：INSERT INTO 表名 (字段1,字段2,…) VALUES(值1,值2,…);<br>(2).给全部字段添加数据：INSERT INTO 表名 VALUES(值1,值2,…);<br>(3).批量添加数据：</p><ul><li>INSERT INTO 表名 (字段名1,字段名2,…) VALUES (值1,值2,…),(值1,值2,…),(值1,值2,…);</li><li>INSERT INTO 表名 VALUES (值1,值2,…),(值1,值2,…),(值1,值2,…);</li></ul><p><span style="color:#FF6B6B">注：</span></p><ul><li><span style="color:#FF6B6B">插入数据时，指定的字段顺序需要与值的顺序是一一对应的</span></li><li><span style="color:#FF6B6B">字符串和日期型数据应该包含在引号中</span></li><li><span style="color:#FF6B6B">插入的数据大小应该在字段的规定范围内</span></li></ul><h3 id="2-修改数据"><a href="#2-修改数据" class="headerlink" title="2.修改数据"></a>2.修改数据</h3><p>(1).修改：UPDATE 表名 SET 字段名1&#x3D;值1,字段名2&#x3D;值2,…[WHERE 条件];<br>(2).删除：DELETE FROM 表名 [WHERE 条件];</p><p><span style="color:#FF6B6B">注：</span></p><ul><li><span style="color:#FF6B6B">DELETE 语句的条件可以有，也可以没有，如果没有条件，就会删除这张表所有数据</span></li><li><span style="color:#FF6B6B">DELETE 语句不能删除某一个字段的值(可以使用UPDATE，直接将该字段修改为null)</span></li></ul><h2 id="四、DQL（数据查询语言）"><a href="#四、DQL（数据查询语言）" class="headerlink" title="四、DQL（数据查询语言）"></a><strong>四、DQL（数据查询语言）</strong></h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h3><p>SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数</p><h3 id="2-基本查询"><a href="#2-基本查询" class="headerlink" title="2.基本查询"></a>2.基本查询</h3><p>(1).查询多个字段：</p><ul><li>SELECT 字段1,字段2,字段3… FROM 表名;</li><li>SELECT * FROM 表名;</li></ul><p>(2).设置别名：SELECT 字段1 [AS 别名1],字段2 [AS 别名2]… FROM 表名;<br>(3).去除重复记录：SELECT DISTINCT 字段列表 FROM 表名;</p><h3 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3.条件查询"></a>3.条件查询</h3><p>(1).语法：SELECT 字段列表 FROM 表名 WHERE 条件列表;<br>(2).条件：</p><ul><li><p>比较运算符</p><blockquote><p><code>&gt;</code>：大于<br> <code>&gt;=</code>：大于等于<br> <code>&lt;</code>：小于<br> <code>&lt;=</code>：小于等于<br><code>=</code>：等于<br> <code>&lt;&gt;</code> 或 <code>!=</code>：不等于<br> <code>BETWEEN...AND...</code>：在某个范围之内（含最小、最大值，<code>BETWEEN</code>后跟最小值，<code>AND</code>后跟最大值）<br> <code>IN(...)</code>：在<code>IN</code>之后的列表中的值，多选一<br> <code>LIKE</code>占位符：模糊匹配（<code>_</code>匹配单个字符，<code>%</code>匹配任意个字符）<br><code>IS NULL</code>：是<code>NULL</code></p></blockquote></li><li><p>逻辑运算符</p><blockquote><p>AND 或 &amp;&amp;：并且（多个条件同时成立）<br>OR 或 ||：或者（多个条件任意一个成立）<br>NOT 或 ！：非，不是</p></blockquote></li></ul><h3 id="4-聚合函数"><a href="#4-聚合函数" class="headerlink" title="4.聚合函数"></a>4.聚合函数</h3><p>(1).介绍：将一列数据作为一个整体，进行纵向计算<br>(2).常见聚合函数</p><blockquote><p>count：统计数量<br>  max：最大值<br>  min：最小值<br>  avg：平均值<br>  sum：求和</p></blockquote><p>(3).语法：SELECT 聚合函数(字段列表) FROM 表名;</p><p><span style="color:#FF6B6B">注：null值不参与所有聚合函数运算</span></p><h3 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5.分组查询"></a>5.分组查询</h3><p>(1).语法：SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];<br>(2).WHERE 与 HAVING区别</p><ul><li>执行时机不同：WHERE是分组前进行过滤，不满足WHERE条件，不参与分组；HAVING是分组后对结果进行过滤</li><li>判断条件不同：WHERE不能对聚合函数进行判断，而HAVING可以</li></ul><h3 id="6-排序查询"><a href="#6-排序查询" class="headerlink" title="6.排序查询"></a>6.排序查询</h3><p>(1).语法：SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;<br>(2).排序方式：</p><ul><li>ASC：升序(默认值)</li><li>DESC：降序</li></ul><p><span style="color:#FF6B6B">注：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</span></p><h3 id="7-分页查询"><a href="#7-分页查询" class="headerlink" title="7.分页查询"></a>7.分页查询</h3><p>(1).语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</p><p><span style="color:#FF6B6B">注：</span></p><ul><li><span style="color:#FF6B6B">起始索引从0开始，起始索引 &#x3D; (查询页码-1) * 每页显示记录数</span></li><li><span style="color:#FF6B6B">分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT</span></li><li><span style="color:#FF6B6B">如果查询的是第一页数据，起始索引可以省略 </span></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库,MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
